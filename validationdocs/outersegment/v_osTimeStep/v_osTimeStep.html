
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>v_osTimeStep</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-12-18"><meta name="DC.source" content="v_osTimeStep.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Function implementing the isetbio validation code</a></li><li><a href="#4">Init</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = v_osTimeStep(varargin)
<span class="comment">%</span>
<span class="comment">% Demonstrate simulations using three different timebases,</span>
<span class="comment">%    For stimuli (based on stimulus refresh rate),</span>
<span class="comment">%    For absorptions and eye movements (based on coneMosaic.integrationTime)</span>
<span class="comment">%    For outer segment current computations (based on os.timeStep)</span>
<span class="comment">%</span>
<span class="comment">% Mainly, we can just use the compute method of the @coneMosaic class for</span>
<span class="comment">% either a single image or for a sequence of oi images (oiSequence class).</span>
<span class="comment">%</span>
<span class="comment">% This script demonstrates the direct usage of the computeForOISequence()</span>
<span class="comment">% method of @coneMosaic. The sequence version of compute calculates</span>
<span class="comment">% absorptions and photocurrents for an oiSequence class of optical images</span>
<span class="comment">% with eye movements.</span>
<span class="comment">%</span>
<span class="comment">% NPC, ISETBIO TEAM, 2016</span>

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
<span class="keyword">end</span>
</pre><h2>Function implementing the isetbio validation code<a name="2"></a></h2><pre class="codeinput"><span class="keyword">function</span> ValidationFunction(runTimeParams)
</pre><p>The ground truth data are no longer consistent. This code is too long, needs some attention and simplification.</p><h2>Init<a name="4"></a></h2><pre class="codeinput">ieInit;

<span class="comment">% Reproduce identical random number</span>
rng(<span class="string">'default'</span>); rng(1);

<span class="comment">% Define number of response instances</span>
instancesNum = 50;

<span class="comment">% Steady params</span>
c0 = struct(<span class="keyword">...</span>
    <span class="string">'mosaicSize'</span>, nan, <span class="keyword">...</span><span class="comment">                      % 1 L-, 1 M-, and 1 S-cone only</span>
    <span class="string">'meanLuminance'</span>, 100, <span class="keyword">...</span><span class="comment">                   % scene mean luminance</span>
    <span class="string">'modulationGain'</span>, 1.0, <span class="keyword">...</span><span class="comment">                  % 100%  modulation against background</span>
    <span class="string">'modulationRegion'</span>, <span class="string">'FULL'</span>, <span class="keyword">...</span><span class="comment">             % modulate the central image (choose b/n 'FULL', and 'CENTER')</span>
    <span class="string">'stimulusSamplingInterval'</span>,  nan, <span class="keyword">...</span><span class="comment">       % we will vary this one</span>
    <span class="string">'integrationTime'</span>, 10/1000, <span class="keyword">...</span><span class="comment">             % 10 msec integrationTime</span>
    <span class="string">'photonNoise'</span>, <span class="string">'frozen'</span>, <span class="keyword">...</span><span class="comment">                % add Poisson noise</span>
    <span class="string">'osTimeStep'</span>, 0.1/1000, <span class="keyword">...</span><span class="comment">                 % 0.1 millisecond</span>
    <span class="string">'osNoise'</span>, <span class="string">'frozen'</span> <span class="keyword">...</span><span class="comment">                     % photocurrent noise</span>
    );


<span class="comment">% Identical stimulus sampling interval and integration time</span>
stimulusConditionIndex = 1;
theCondition = c0;
theCondition.stimulusSamplingInterval = 10/1000;
c{stimulusConditionIndex} = theCondition;

<span class="comment">% Stimulus sampling interval &lt; integration time</span>
stimulusConditionIndex = 2;
theCondition = c0;
theCondition.stimulusSamplingInterval = 7/1000;
c{stimulusConditionIndex} = theCondition;

<span class="comment">% Stimulus sampling interval &gt; integration time</span>
stimulusConditionIndex = 3;
theCondition = c0;
theCondition.stimulusSamplingInterval = 16/1000;
c{stimulusConditionIndex} = theCondition;


<span class="keyword">for</span> stimulusConditionIndex = 1:numel(c)

   [ theConeMosaic{stimulusConditionIndex}, <span class="keyword">...</span>
     theOIsequence{stimulusConditionIndex}, <span class="keyword">...</span>
     oiTimeAxis{stimulusConditionIndex}, <span class="keyword">...</span>
     absorptionsTimeAxis{stimulusConditionIndex}, <span class="keyword">...</span>
     photocurrentsTimeAxis{stimulusConditionIndex}, <span class="keyword">...</span>
     allInstancesAbsorptionsCountSequence{stimulusConditionIndex}, <span class="keyword">...</span>
     allInstancesIsomerizationRateSequence{stimulusConditionIndex}, <span class="keyword">...</span>
     allInstancesPhotoCurrents{stimulusConditionIndex} <span class="keyword">...</span>
   ] = runSimulation(c{stimulusConditionIndex}, instancesNum, runTimeParams);

    <span class="keyword">if</span> (runTimeParams.generatePlots)
        plotSNR(absorptionsTimeAxis{stimulusConditionIndex}, <span class="keyword">...</span>
            oiTimeAxis{stimulusConditionIndex}, <span class="keyword">...</span>
            photocurrentsTimeAxis{stimulusConditionIndex}, <span class="keyword">...</span>
            allInstancesAbsorptionsCountSequence{stimulusConditionIndex}, <span class="keyword">...</span>
            allInstancesPhotoCurrents{stimulusConditionIndex}, <span class="keyword">...</span>
            stimulusConditionIndex);
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">% Save validation data</span>
<span class="comment">% conditions data</span>
UnitTest.validationData(<span class="string">'condParams'</span>, c);

UnitTest.validationData(<span class="string">'oiTimeAxisCond1'</span>, oiTimeAxis{1});
UnitTest.validationData(<span class="string">'absorptionsTimeAxisCond1'</span>, absorptionsTimeAxis{1});
UnitTest.validationData(<span class="string">'photoCurrentTimeAxisCond1'</span>, photocurrentsTimeAxis{1});
UnitTest.validationData(<span class="string">'allInstancesAbsorptionsCountSequenceCond1'</span>, allInstancesAbsorptionsCountSequence{1});
UnitTest.validationData(<span class="string">'allInstancesIsomerizationRateSequenceCond1'</span>, round(allInstancesIsomerizationRateSequence{1}, 4));
UnitTest.validationData(<span class="string">'allInstancesPhotoCurrentsCond1'</span>, round(allInstancesPhotoCurrents{1}, 5));

UnitTest.validationData(<span class="string">'oiTimeAxisCond2'</span>, oiTimeAxis{2});
UnitTest.validationData(<span class="string">'absorptionsTimeAxisCond2'</span>, absorptionsTimeAxis{2});
UnitTest.validationData(<span class="string">'photoCurrentTimeAxisCond2'</span>, photocurrentsTimeAxis{2});
UnitTest.validationData(<span class="string">'allInstancesAbsorptionsCountSequenceCond2'</span>, allInstancesAbsorptionsCountSequence{2});
UnitTest.validationData(<span class="string">'allInstancesIsomerizationRateSequenceCond2'</span>, round(allInstancesIsomerizationRateSequence{2}, 4));
UnitTest.validationData(<span class="string">'allInstancesPhotoCurrentsCond2'</span>, round(allInstancesPhotoCurrents{2}, 5));

UnitTest.validationData(<span class="string">'oiTimeAxisCond3'</span>, oiTimeAxis{3});
UnitTest.validationData(<span class="string">'absorptionsTimeAxisCond3'</span>, absorptionsTimeAxis{3});
UnitTest.validationData(<span class="string">'photoCurrentTimeAxisCond3'</span>, photocurrentsTimeAxis{3});
UnitTest.validationData(<span class="string">'allInstancesAbsorptionsCountSequenceCond3'</span>, allInstancesAbsorptionsCountSequence{3});
UnitTest.validationData(<span class="string">'allInstancesIsomerizationRateSequenceCond3'</span>, round(allInstancesIsomerizationRateSequence{3}, 4));
UnitTest.validationData(<span class="string">'allInstancesPhotoCurrentsCond3'</span>, round(allInstancesPhotoCurrents{3}, 5));

<span class="comment">% Extra data: coneMosaics and oiSequences</span>
UnitTest.extraData(<span class="string">'theConeMosaicCond1'</span>, theConeMosaic{1});
UnitTest.extraData(<span class="string">'theOIsequenceCond1'</span>, theOIsequence{1});
UnitTest.extraData(<span class="string">'theConeMosaicCond2'</span>, theConeMosaic{2});
UnitTest.extraData(<span class="string">'theOIsequenceCond2'</span>, theOIsequence{2});
UnitTest.extraData(<span class="string">'theConeMosaicCond3'</span>, theConeMosaic{3});
UnitTest.extraData(<span class="string">'theOIsequenceCond4'</span>, theOIsequence{3});
</pre><pre class="codeoutput">Frozen noise added: seed 103
Frozen noise added: seed 104
Frozen noise added: seed 105
Frozen noise added: seed 106
Frozen noise added: seed 107
Frozen noise added: seed 108
Frozen noise added: seed 109
Frozen noise added: seed 110
Frozen noise added: seed 111
Frozen noise added: seed 112
Frozen noise added: seed 113
Frozen noise added: seed 114
Frozen noise added: seed 115
Frozen noise added: seed 116
Frozen noise added: seed 117
Frozen noise added: seed 118
Frozen noise added: seed 119
Frozen noise added: seed 120
Frozen noise added: seed 121
Frozen noise added: seed 122
Frozen noise added: seed 123
Frozen noise added: seed 124
Frozen noise added: seed 125
Frozen noise added: seed 126
Frozen noise added: seed 127
Frozen noise added: seed 128
Frozen noise added: seed 129
Frozen noise added: seed 130
Frozen noise added: seed 131
Frozen noise added: seed 132
Frozen noise added: seed 133
Frozen noise added: seed 134
Frozen noise added: seed 135
Frozen noise added: seed 136
Frozen noise added: seed 137
Frozen noise added: seed 138
Frozen noise added: seed 139
Frozen noise added: seed 140
Frozen noise added: seed 141
Frozen noise added: seed 142
Frozen noise added: seed 143
Frozen noise added: seed 144
Frozen noise added: seed 145
Frozen noise added: seed 146
Frozen noise added: seed 147
Frozen noise added: seed 148
Frozen noise added: seed 149
Frozen noise added: seed 150
Frozen noise added: seed 151
Frozen noise added: seed 152
Frozen noise added: seed 103
Frozen noise added: seed 105
Frozen noise added: seed 106
Frozen noise added: seed 107
Frozen noise added: seed 108
Frozen noise added: seed 109
Frozen noise added: seed 110
Frozen noise added: seed 111
Frozen noise added: seed 112
Frozen noise added: seed 113
Frozen noise added: seed 114
Frozen noise added: seed 115
Frozen noise added: seed 116
Frozen noise added: seed 117
Frozen noise added: seed 118
Frozen noise added: seed 119
Frozen noise added: seed 120
Frozen noise added: seed 121
Frozen noise added: seed 122
Frozen noise added: seed 123
Frozen noise added: seed 124
Frozen noise added: seed 125
Frozen noise added: seed 126
Frozen noise added: seed 127
Frozen noise added: seed 128
Frozen noise added: seed 129
Frozen noise added: seed 130
Frozen noise added: seed 131
Frozen noise added: seed 132
Frozen noise added: seed 133
Frozen noise added: seed 134
Frozen noise added: seed 135
Frozen noise added: seed 136
Frozen noise added: seed 137
Frozen noise added: seed 138
Frozen noise added: seed 139
Frozen noise added: seed 140
Frozen noise added: seed 141
Frozen noise added: seed 142
Frozen noise added: seed 143
Frozen noise added: seed 144
Frozen noise added: seed 145
Frozen noise added: seed 146
Frozen noise added: seed 147
Frozen noise added: seed 148
Frozen noise added: seed 149
Frozen noise added: seed 150
Frozen noise added: seed 151
Frozen noise added: seed 152
Frozen noise added: seed 153
Frozen noise added: seed 154
Frozen noise added: seed 105
Frozen noise added: seed 70
Frozen noise added: seed 71
Frozen noise added: seed 72
Frozen noise added: seed 73
Frozen noise added: seed 74
Frozen noise added: seed 75
Frozen noise added: seed 76
Frozen noise added: seed 77
Frozen noise added: seed 78
Frozen noise added: seed 79
Frozen noise added: seed 80
Frozen noise added: seed 81
Frozen noise added: seed 82
Frozen noise added: seed 83
Frozen noise added: seed 84
Frozen noise added: seed 85
Frozen noise added: seed 86
Frozen noise added: seed 87
Frozen noise added: seed 88
Frozen noise added: seed 89
Frozen noise added: seed 90
Frozen noise added: seed 91
Frozen noise added: seed 92
Frozen noise added: seed 93
Frozen noise added: seed 94
Frozen noise added: seed 95
Frozen noise added: seed 96
Frozen noise added: seed 97
Frozen noise added: seed 98
Frozen noise added: seed 99
Frozen noise added: seed 100
Frozen noise added: seed 101
Frozen noise added: seed 102
Frozen noise added: seed 103
Frozen noise added: seed 104
Frozen noise added: seed 105
Frozen noise added: seed 106
Frozen noise added: seed 107
Frozen noise added: seed 108
Frozen noise added: seed 109
Frozen noise added: seed 110
Frozen noise added: seed 111
Frozen noise added: seed 112
Frozen noise added: seed 113
Frozen noise added: seed 114
Frozen noise added: seed 115
Frozen noise added: seed 116
Frozen noise added: seed 117
Frozen noise added: seed 118
Frozen noise added: seed 119
Frozen noise added: seed 70
</pre><img vspace="5" hspace="5" src="v_osTimeStep_01.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="v_osTimeStep_02.png" style="width:1800px;height:1180px;" alt=""> <img vspace="5" hspace="5" src="v_osTimeStep_03.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="v_osTimeStep_04.png" style="width:1800px;height:1180px;" alt=""> <img vspace="5" hspace="5" src="v_osTimeStep_05.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="v_osTimeStep_06.png" style="width:1800px;height:1180px;" alt=""> <pre class="codeinput"><span class="keyword">end</span>


<span class="comment">% ------- Main computation function --------</span>

<span class="keyword">function</span> [theConeMosaic, theOIsequence, <span class="keyword">...</span>
    oiTimeAxis, absorptionsTimeAxis, photocurrentsTimeAxis, <span class="keyword">...</span>
    allInstancesAbsorptionsCountSequence, <span class="keyword">...</span>
    allInstancesIsomerizationRateSequence, <span class="keyword">...</span>
    allInstancesPhotoCurrents] = runSimulation(condData, instancesNum, runtimeParams)

    mosaicSize = condData.mosaicSize;
    meanLuminance = condData.meanLuminance;
    modulationGain = condData.modulationGain;
    modulationRegion = condData.modulationRegion;
    stimulusSamplingInterval = condData.stimulusSamplingInterval;
    integrationTime = condData.integrationTime;
    osTimeStep = condData.osTimeStep;
    photonNoise = condData.photonNoise;
    osNoise = condData.osNoise;

    <span class="comment">% Define the time axis for the simulation</span>
    oiTimeAxis = 0:stimulusSamplingInterval:0.4;
    oiTimeAxis = oiTimeAxis - mean(oiTimeAxis);

    <span class="comment">% Compute the stimulus modulation function</span>
    stimulusRampTau = 0.07;
    modulationFunction = modulationGain * exp(-0.5*(oiTimeAxis/stimulusRampTau).^2);

    <span class="comment">% Generate a uniform field scene with desired mean luminance</span>
    <span class="keyword">if</span> (isnan(mosaicSize))
        FOV = 0.2;
    <span class="keyword">else</span>
        FOV = max(mosaicSize);
    <span class="keyword">end</span>

    <span class="comment">% Generate the scene</span>
    theScene = uniformFieldSceneCreate(FOV, meanLuminance);

    <span class="comment">% Generate optics</span>
    noOptics = false;
    theOI = oiGenerate(noOptics);

    <span class="comment">% Generate the sequence of optical images</span>
    theOIsequence = oiSequenceGenerate(theScene, theOI, oiTimeAxis, modulationFunction, <span class="string">'CENTER'</span>);
    <span class="keyword">if</span> (runtimeParams.generatePlots)
        <span class="comment">%theOIsequence.visualize('format', 'montage');</span>
        theOIsequence.visualize();
    <span class="keyword">end</span>

    <span class="comment">% Generate the cone mosaic with eye movements for theOIsequence</span>
    theConeMosaic = coneMosaicGenerate(mosaicSize, photonNoise, osNoise, integrationTime, osTimeStep);

    <span class="comment">% Generate eye movement paths for all instances</span>
    eyeMovementsNum = theOIsequence.maxEyeMovementsNumGivenIntegrationTime(theConeMosaic.integrationTime);
    emPaths = zeros(instancesNum, eyeMovementsNum,2);
    <span class="keyword">for</span> instanceIndex = 1:instancesNum
        emPaths(instanceIndex, :, :) = theConeMosaic.emGenSequence(eyeMovementsNum)*0;
    <span class="keyword">end</span>

    <span class="comment">% Compute all instances</span>
    [allInstancesAbsorptionsCountSequence, allInstancesPhotoCurrents] = <span class="keyword">...</span>
            theConeMosaic.computeForOISequence(theOIsequence, <span class="keyword">...</span>
            <span class="string">'emPaths'</span>, emPaths, <span class="keyword">...</span>
            <span class="string">'currentFlag'</span>, true);
     absorptionsTimeAxis = theConeMosaic.timeAxis + theOIsequence.timeAxis(1);
     photocurrentsTimeAxis = absorptionsTimeAxis;

     <span class="comment">% Compute photon rate from photon count</span>
     allInstancesIsomerizationRateSequence = allInstancesAbsorptionsCountSequence / theConeMosaic.integrationTime;


     <span class="comment">% Internal consistency checks</span>
     <span class="comment">% Check that the data in the absorptions property agrees with the data in the last instance of allInstancesAbsorptionsCountSequence</span>
     lastInstance = size(allInstancesAbsorptionsCountSequence,1);
     s1 = single(theConeMosaic.absorptions);
     s2 = single(reshape(squeeze(allInstancesAbsorptionsCountSequence(lastInstance,:,:,:)), [size(theConeMosaic.pattern,1) size(theConeMosaic.pattern,2) numel(absorptionsTimeAxis)]));

     tolerance = 1E-6;
     quantityOfInterest = s1(:)-s2(:);
     UnitTest.assertIsZero(quantityOfInterest,<span class="string">'coneMosaic.computeForOISequence: absorptions from coneMosaic property and returned absorptions'</span>,tolerance);

     <span class="comment">% Check that the data in the current property agrees with the data in the last instance of allInstancesPhotoCurrents</span>
     s1 = single(theConeMosaic.current);
     s2 = single(reshape(allInstancesPhotoCurrents(lastInstance,:,:,:), <span class="keyword">...</span>
         size(theConeMosaic.pattern,1), size(theConeMosaic.pattern,2), size(allInstancesPhotoCurrents,4)));

     tolerance = 1E-6;
     quantityOfInterest = s1(:)-s2(:);
     UnitTest.assertIsZero(quantityOfInterest,<span class="string">'coneMosaic.computeForOISequence: current from coneMosaic property and returned photocurrents'</span>,tolerance);

     <span class="comment">% Compute responses for the first instance only using the coneMosaic.compute() method</span>
     [allInstancesAbsorptionsCountSequence2, allInstancesPhotoCurrents2] = <span class="keyword">...</span>
            theConeMosaic.compute(theOIsequence, <span class="keyword">...</span>
            <span class="string">'emPath'</span>, emPaths(1,:,:), <span class="keyword">...</span>
            <span class="string">'currentFlag'</span>, true);
     absorptionsTimeAxis2 = theConeMosaic.timeAxis + theOIsequence.timeAxis(1);
     photocurrentsTimeAxis2 = absorptionsTimeAxis2;

     <span class="comment">% Check that the data in the absorptions property agrees with the data in the last instance of allInstancesAbsorptionsCountSequence</span>
     lastInstance = size(allInstancesAbsorptionsCountSequence2,1);
     s1 = single(theConeMosaic.absorptions);
     s2 = single(reshape(squeeze(allInstancesAbsorptionsCountSequence2(lastInstance,:,:,:)), [size(theConeMosaic.pattern,1) size(theConeMosaic.pattern,2) numel(absorptionsTimeAxis2)]));

     tolerance = 1E-6;
     quantityOfInterest = s1(:)-s2(:);
     UnitTest.assertIsZero(quantityOfInterest,<span class="string">'coneMosaic.compute: absorptions from coneMosaic property and returned absorptions'</span>,tolerance);

     <span class="comment">% Check that the data in the current property agrees with the data in the last instance of allInstancesPhotoCurrents</span>
     s1 = single(theConeMosaic.current);
     s2 = single(reshape(allInstancesPhotoCurrents2(lastInstance,:,:,:), <span class="keyword">...</span>
         size(theConeMosaic.pattern,1), size(theConeMosaic.pattern,2), size(allInstancesPhotoCurrents2,4)));

     tolerance = 1E-6;
     quantityOfInterest = s1(:)-s2(:);
     UnitTest.assertIsZero(quantityOfInterest,<span class="string">'coneMosaic.compute: current from coneMosaic property and returned photocurrents'</span>,tolerance);
<span class="keyword">end</span>


<span class="comment">% ------- Helper functions --------</span>

<span class="keyword">function</span> theConeMosaic = coneMosaicGenerate(mosaicSize, photonNoise, osNoise, integrationTime, osTimeStep)
    <span class="comment">% Default human mosaic</span>
    theConeMosaic = coneMosaic;

    <span class="comment">% Adjust size</span>
    <span class="keyword">if</span> isnan(mosaicSize)
        <span class="comment">% Generate a human cone mosaic with 1L, 1M and 1S cone</span>
        theConeMosaic.rows = 1;
        theConeMosaic.cols = 3;
        theConeMosaic.pattern = [2 3 4];
    <span class="keyword">else</span>
        theConeMosaic.setSizeToFOV(mosaicSize);
    <span class="keyword">end</span>

    <span class="comment">% Set the noise</span>
    theConeMosaic.noiseFlag = photonNoise;

    <span class="comment">% Set the integrationTime</span>
    theConeMosaic.integrationTime = integrationTime;

    <span class="comment">% Generate the outer-segment object to be used by the coneMosaic</span>
    theOuterSegment = osLinear();
    theOuterSegment.noiseFlag = osNoise;

    <span class="comment">% Set a custom timeStep, for @osLinear we do not need the default 0.1 msec</span>
    theOuterSegment.timeStep = osTimeStep;

    <span class="comment">% Couple the outersegment object to the cone mosaic object</span>
    theConeMosaic.os = theOuterSegment;
<span class="keyword">end</span>


<span class="keyword">function</span> theOIsequence = oiSequenceGenerate(theScene, theOI, oiTimeAxis, modulationFunction, modulationType)
    <span class="comment">% Compute the background and modulated optical images</span>
    oiBackground = oiCompute(theOI, theScene);
    oiModulated  = oiBackground;

    <span class="keyword">if</span> strcmp(modulationType, <span class="string">'FULL'</span>)
        theOIsequence = oiSequence(oiBackground, oiModulated, oiTimeAxis, modulationFunction);
    <span class="keyword">else</span>
        pos = oiGet(oiBackground, <span class="string">'spatial support'</span>, <span class="string">'microns'</span>);
        modulationRegion.radiusInMicrons = 0.5*max(pos(:));
        theOIsequence = oiSequence(oiBackground, oiModulated, oiTimeAxis, modulationFunction, <span class="string">'modulationRegion'</span>, modulationRegion);
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> theOI = oiGenerate(noOptics)
    <span class="comment">% Generate optics</span>
    <span class="keyword">if</span> (noOptics)
        theOI = oiCreate(<span class="string">'diffraction limited'</span>);
        optics = oiGet(theOI,<span class="string">'optics'</span>);
        optics = opticsSet(optics,<span class="string">'fnumber'</span>,0);
        optics = opticsSet(optics, <span class="string">'off axis method'</span>, <span class="string">'skip'</span>);
        theOI = oiSet(theOI,<span class="string">'optics'</span>, optics);
    <span class="keyword">else</span>
        theOI = oiCreate(<span class="string">'human'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> uniformScene = uniformFieldSceneCreate(FOV, meanLuminance)
    uniformScene = sceneCreate(<span class="string">'uniform equal photon'</span>, 128);
    <span class="comment">% square scene with desired FOV</span>
    uniformScene = sceneSet(uniformScene, <span class="string">'wAngular'</span>, FOV);
    <span class="comment">% 1 meter away</span>
    uniformScene = sceneSet(uniformScene, <span class="string">'distance'</span>, 1.0);
    <span class="comment">% adjust radiance according to desired  mean luminance</span>
    uniformScene = sceneAdjustLuminance(uniformScene, meanLuminance);
<span class="keyword">end</span>


<span class="comment">% --- Plotting function ----</span>

<span class="keyword">function</span> plotSNR(isomerizationsTimeAxis, oiTimeAxis, photocurrentTime, allInstancesIsomerizationsCount, allInstancesPhotoCurrents, figNo)

    <span class="comment">% Compute isomerization means and stds across all instances</span>
    isomerizationMeans = mean(allInstancesIsomerizationsCount, 1);
    isomerizationSTDs = std(allInstancesIsomerizationsCount, 0, 1);

    <span class="comment">% Subtract baseline from all photocurrents</span>
    normalizePhotocurrents = true;
    <span class="keyword">if</span> (normalizePhotocurrents)
        minLMS = squeeze(min(min(min(allInstancesPhotoCurrents,[],1), [],2), [], 4));
        photocurrentBaseline = ones(size(allInstancesPhotoCurrents));
        <span class="keyword">for</span> coneIndex = 1:3
            photocurrentBaseline(:,:,coneIndex,:) = minLMS(coneIndex);
        <span class="keyword">end</span>
        photocurrentRange = [0 60];
    <span class="keyword">else</span>
        photocurrentBaseline = allInstancesPhotoCurrents(:,:,:,1)*0;
        photocurrentBaseline = reshape(photocurrentBaseline, [size(allInstancesPhotoCurrents,1) size(allInstancesPhotoCurrents,2) size(allInstancesPhotoCurrents,3) 1]);
        photocurrentRange = [min(allInstancesPhotoCurrents(:)) max(allInstancesPhotoCurrents(:))];

    <span class="keyword">end</span>
    allInstancesPhotoCurrents = bsxfun(@minus, allInstancesPhotoCurrents, photocurrentBaseline);


    <span class="comment">% compute photocurrent means and stds across all instances</span>
    photocurrentMeansBaselineCorrected  = mean(allInstancesPhotoCurrents,1);
    photocurrentSTDsBaselineCorrected   = std(allInstancesPhotoCurrents, 0, 1);


    dt = isomerizationsTimeAxis(2)-isomerizationsTimeAxis(1);
    instancesNum = size(allInstancesIsomerizationsCount,1);
    <span class="comment">% Plotting limits</span>
    absorptionsFanoFactorLims = [0.0 10];
    photocurrentFanoFactorLims = [0.0 10];
    SNRlims = [0 60];

    hFig = figure(figNo+1000); clf;
    set(hFig, <span class="string">'Position'</span>, [10+figNo*10 10 1800 1180], <span class="string">'Color'</span>, [0 0 0]);

    colors = [1 0 0; 0 1.0 0; 0 0.8 1];
    coneNames = {<span class="string">'L-cone'</span>, <span class="string">'M-cone'</span>, <span class="string">'S-cone'</span>};

    subplotPosVectors = NicePlot.getSubPlotPosVectors(<span class="keyword">...</span>
           <span class="string">'rowsNum'</span>, 3, <span class="keyword">...</span>
           <span class="string">'colsNum'</span>, 6, <span class="keyword">...</span>
           <span class="string">'heightMargin'</span>,   0.04, <span class="keyword">...</span>
           <span class="string">'widthMargin'</span>,    0.05, <span class="keyword">...</span>
           <span class="string">'leftMargin'</span>,     0.05, <span class="keyword">...</span>
           <span class="string">'rightMargin'</span>,    0.00, <span class="keyword">...</span>
           <span class="string">'bottomMargin'</span>,   0.04, <span class="keyword">...</span>
           <span class="string">'topMargin'</span>,      0.04);

    <span class="keyword">for</span> coneType = 1:3

        mu = squeeze(isomerizationMeans(1,1, coneType,:));
        sigma = squeeze(isomerizationSTDs(1,1, coneType,:));
        <span class="comment">% avoid divisions by zero</span>
        sigma(mu == 0) = 1;

        variance = sigma.^2;
        isomerizationsInverseFanoFactor = mu ./ variance;
        isomerizationsSNR = mu ./sigma;

        mu = squeeze(photocurrentMeansBaselineCorrected(1,1,coneType,:));
        sigma = squeeze(photocurrentSTDsBaselineCorrected(1,1,coneType,:));
        <span class="comment">% avoid divisions by near zero by making very small photocurrents = 0</span>
        sigma(mu &lt; 0.1) = 1;
        mu(mu &lt; 0.1) = 0;

        variance = sigma.^2;
        photocurrentInverseFanoFactor = mu ./variance;
        photocurrentSNR = mu ./ sigma;

        maxIsomerizationCountForThisCone = max(max(max(squeeze(allInstancesIsomerizationsCount(:,:,coneType,:))))) + 1;
        minIsomerizationCountForThisCone = min(min(min(squeeze(allInstancesIsomerizationsCount(:,:, coneType,:)))));

        plotBackgroundColor = [0.1 0.1 0.1];

        <span class="comment">% Absorption events</span>
        subplot(<span class="string">'Position'</span>, subplotPosVectors(coneType,1).v);
        hold <span class="string">on</span>
        <span class="comment">% Identify stimulus presentation times</span>
        <span class="keyword">for</span> k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], [minIsomerizationCountForThisCone maxIsomerizationCountForThisCone], <span class="string">'k-'</span>, <span class="string">'Color'</span>, [0.5 0.5 0.5]);
        <span class="keyword">end</span>

        barOpacity = 0.25;
        <span class="keyword">for</span> tIndex = 1:numel(isomerizationsTimeAxis)
            quantaAtThisTimeBin = squeeze(allInstancesIsomerizationsCount(:,1, coneType,tIndex));
            plot([isomerizationsTimeAxis(tIndex) isomerizationsTimeAxis(tIndex)+dt], [quantaAtThisTimeBin(:) quantaAtThisTimeBin(:)], <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1.5, <span class="string">'Color'</span>, [colors(coneType,:) barOpacity]);
        <span class="keyword">end</span>
        box <span class="string">on</span>;
        set(gca, <span class="string">'XColor'</span>, [0.8 0.8 0.8], <span class="string">'YColor'</span>, [0.8 0.8 0.8], <span class="string">'Color'</span>, plotBackgroundColor, <span class="string">'FontSize'</span>, 14, <span class="string">'XLim'</span>, [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt], <span class="string">'YLim'</span>, [minIsomerizationCountForThisCone maxIsomerizationCountForThisCone]);
        <span class="keyword">if</span> (coneType == 3)
            xlabel(<span class="string">'time (seconds)'</span>, <span class="string">'FontSize'</span>, 16);
        <span class="keyword">end</span>
        ylabel(sprintf(<span class="string">'%s isomerizations in %2.1f msec'</span>, coneNames{coneType}, 1000*dt), <span class="string">'FontSize'</span>, 16, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>, <span class="string">'Color'</span>, [1 1 0.3]);
        <span class="keyword">if</span> (coneType == 1)
            title(sprintf(<span class="string">'isomerizations\n(%d instances)'</span>, instancesNum), <span class="string">'FontSize'</span>, 16, <span class="string">'Color'</span>, [1 1 1]);
        <span class="keyword">end</span>



        <span class="comment">% Absorptions InverseFanoFactor</span>
        subplot(<span class="string">'Position'</span>, subplotPosVectors(coneType,2).v);
        hold <span class="string">on</span>
        <span class="comment">% Identify stimulus presentation times</span>
        <span class="keyword">for</span> k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], absorptionsFanoFactorLims, <span class="string">'k-'</span>, <span class="string">'Color'</span>, [0.5 0.5 0.5]);
        <span class="keyword">end</span>
        <span class="comment">% Identify the FanoFactor = 1 line</span>
        plot([isomerizationsTimeAxis isomerizationsTimeAxis(end)+dt], [ones(size(isomerizationsTimeAxis)) 1], <span class="string">'--'</span>, <span class="string">'Color'</span>, [0.8 0.8 0.3], <span class="string">'LineWidth'</span>, 1.5);
        <span class="comment">% Plot the time-varying Fano factor</span>
        <span class="keyword">for</span> tIndex = 1:numel(isomerizationsTimeAxis)
            <span class="keyword">if</span> (tIndex &lt; numel(isomerizationsTimeAxis))
                xx = [isomerizationsTimeAxis(tIndex) isomerizationsTimeAxis(tIndex)+dt isomerizationsTimeAxis(tIndex+1)];
                yy = [isomerizationsInverseFanoFactor(tIndex) * [1 1] isomerizationsInverseFanoFactor(tIndex+1)];
            <span class="keyword">else</span>
                xx = [isomerizationsTimeAxis(tIndex) isomerizationsTimeAxis(tIndex)+dt];
                yy = isomerizationsInverseFanoFactor(tIndex) * [1 1];
            <span class="keyword">end</span>
            plot(xx,yy, <span class="string">'-'</span>, <span class="string">'Color'</span>, colors(coneType,:), <span class="string">'LineWidth'</span>, 1.5);
        <span class="keyword">end</span>
        box <span class="string">on</span>;
        yTicks = [0 1 2 4 8];
        set(gca, <span class="string">'XColor'</span>, [0.8 0.8 0.8], <span class="string">'YColor'</span>, [0.8 0.8 0.8], <span class="string">'Color'</span>, plotBackgroundColor, <span class="string">'FontSize'</span>, 14, <span class="string">'XLim'</span>, [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt], <span class="string">'YLim'</span>, absorptionsFanoFactorLims, <span class="string">'YScale'</span>, <span class="string">'Linear'</span>, <span class="string">'YTick'</span>, yTicks, <span class="string">'YTickLabel'</span>, sprintf(<span class="string">'%2.2f\n'</span>, yTicks));
        <span class="keyword">if</span> (coneType == 3)
            xlabel(<span class="string">'time (seconds)'</span>, <span class="string">'FontSize'</span>, 16);
        <span class="keyword">end</span>
        ylabel(<span class="string">'quanta inverse Fano factor ( \mu/{\sigma}^2 )'</span>, <span class="string">'FontSize'</span>, 16, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>, <span class="string">'Color'</span>, [1 1 0.3]);
        <span class="keyword">if</span> (coneType == 1)
            title(<span class="string">'Inv. Fano Factor ( \mu/{\sigma}^2 )'</span>, <span class="string">'FontSize'</span>, 16, <span class="string">'Color'</span>, [1 1 1]);
        <span class="keyword">end</span>

        <span class="comment">% Absorptions SNR</span>
        subplot(<span class="string">'Position'</span>, subplotPosVectors(coneType,3).v);
        hold <span class="string">on</span>
        <span class="comment">% Identify stimulus presentation times</span>
        <span class="keyword">for</span> k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], SNRlims, <span class="string">'k-'</span>, <span class="string">'Color'</span>, [0.5 0.5 0.5]);
        <span class="keyword">end</span>
        <span class="comment">% Plot the time-varying SNR</span>
        <span class="keyword">for</span> tIndex = 1:numel(isomerizationsTimeAxis)
            <span class="keyword">if</span> (tIndex &lt; numel(isomerizationsTimeAxis))
                xx = [isomerizationsTimeAxis(tIndex) isomerizationsTimeAxis(tIndex)+dt isomerizationsTimeAxis(tIndex+1)];
                yy = [isomerizationsSNR(tIndex) * [1 1] isomerizationsSNR(tIndex+1)];
            <span class="keyword">else</span>
                xx = [isomerizationsTimeAxis(tIndex) isomerizationsTimeAxis(tIndex)+dt];
                yy = isomerizationsSNR(tIndex) * [1 1];
            <span class="keyword">end</span>
            plot(xx,yy, <span class="string">'-'</span>, <span class="string">'Color'</span>, colors(coneType,:), <span class="string">'LineWidth'</span>, 1.5);
        <span class="keyword">end</span>
        box <span class="string">on</span>;
        set(gca, <span class="string">'XColor'</span>, [0.8 0.8 0.8], <span class="string">'YColor'</span>, [0.8 0.8 0.8], <span class="string">'Color'</span>, plotBackgroundColor, <span class="string">'FontSize'</span>, 14, <span class="string">'XLim'</span>, [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt],  <span class="string">'YLim'</span>, SNRlims, <span class="string">'YScale'</span>, <span class="string">'Linear'</span>);
        <span class="keyword">if</span> (coneType == 3)
            xlabel(<span class="string">'time (seconds)'</span>, <span class="string">'FontSize'</span>, 16);
        <span class="keyword">end</span>
        ylabel(<span class="string">'quanta SNR ( \mu/\sigma )'</span>, <span class="string">'FontSize'</span>, 16, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>, <span class="string">'Color'</span>, [1 1 0.3]);
        <span class="keyword">if</span> (coneType == 1)
            title(<span class="string">'SNR ( \mu/\sigma )'</span>, <span class="string">'FontSize'</span>, 16, <span class="string">'Color'</span>, [1 1 1]);
        <span class="keyword">end</span>


        <span class="comment">% photocurrents</span>
        subplot(<span class="string">'Position'</span>, subplotPosVectors(coneType,4).v);
        <span class="comment">% Identify stimulus presentation times</span>
        hold <span class="string">on</span>
        <span class="keyword">for</span> k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], photocurrentRange, <span class="string">'k-'</span>, <span class="string">'Color'</span>, [0.5 0.5 0.5]);
        <span class="keyword">end</span>

        <span class="comment">% Plot photocurrents</span>
        plot(photocurrentTime, squeeze(allInstancesPhotoCurrents(:,1,coneType, :)), <span class="string">'LineWidth'</span>, 1.5, <span class="string">'Color'</span>, [colors(coneType,:) barOpacity*2]);
        box <span class="string">on</span>;
        set(gca, <span class="string">'XColor'</span>, [0.8 0.8 0.8], <span class="string">'YColor'</span>, [0.8 0.8 0.8], <span class="string">'Color'</span>, plotBackgroundColor, <span class="string">'FontSize'</span>, 14, <span class="string">'XLim'</span>, [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt], <span class="string">'YLim'</span>, photocurrentRange);
        <span class="keyword">if</span> (coneType == 3)
            xlabel(<span class="string">'time (seconds)'</span>, <span class="string">'FontSize'</span>, 16);
        <span class="keyword">end</span>
        ylabel(<span class="string">'photocurrent (pA)'</span>, <span class="string">'FontSize'</span>, 16, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>, <span class="string">'Color'</span>, [1 1 0.3]);
        <span class="keyword">if</span> (coneType == 1)
            title(sprintf(<span class="string">'pcurrent, os.noiseFlag=false\n (%d instances)'</span>, instancesNum), <span class="string">'FontSize'</span>, 16, <span class="string">'Color'</span>, [1 1 1]);
        <span class="keyword">end</span>

        <span class="comment">% Photocurrent time-varying inverse FanoFactor</span>

        subplot(<span class="string">'Position'</span>, subplotPosVectors(coneType,5).v);
        hold <span class="string">on</span>
        <span class="comment">% Identify stimulus presentation times</span>
        <span class="keyword">for</span> k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], photocurrentFanoFactorLims, <span class="string">'k-'</span>, <span class="string">'Color'</span>, [0.5 0.5 0.5]);
        <span class="keyword">end</span>
        <span class="comment">% Identify the FanoFactor = 1 line</span>
        plot([photocurrentTime photocurrentTime(end)], [ones(size(photocurrentTime)) 1], <span class="string">'--'</span>, <span class="string">'Color'</span>, [0.8 0.8 0.3], <span class="string">'LineWidth'</span>, 1.5);
        <span class="comment">% Plot the time-varying Fano factor</span>
        stairs(photocurrentTime, photocurrentInverseFanoFactor, <span class="string">'Color'</span>, colors(coneType,:), <span class="string">'LineWidth'</span>, 1.5);
        box <span class="string">on</span>;
        yTicks = [0 1 2 4 8];
        set(gca, <span class="string">'XColor'</span>, [0.8 0.8 0.8], <span class="string">'YColor'</span>, [0.8 0.8 0.8], <span class="string">'Color'</span>, plotBackgroundColor, <span class="string">'FontSize'</span>, 14, <span class="string">'XLim'</span>, [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt], <span class="string">'YLim'</span>, photocurrentFanoFactorLims, <span class="string">'YScale'</span>, <span class="string">'Linear'</span>, <span class="string">'YTick'</span>, yTicks, <span class="string">'YTickLabel'</span>, sprintf(<span class="string">'%2.2f\n'</span>, yTicks));
        <span class="keyword">if</span> (coneType == 3)
            xlabel(<span class="string">'time (seconds)'</span>, <span class="string">'FontSize'</span>, 16);
        <span class="keyword">end</span>
        ylabel(<span class="string">'photocurrent Inverse Fano factor ( \mu/{\sigma}^2 )'</span>, <span class="string">'FontSize'</span>, 16, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>, <span class="string">'Color'</span>, [1 1 0.3]);
        <span class="keyword">if</span> (coneType == 1)
            title(<span class="string">'Inv. Fano Factor ( \mu/{\sigma}^2 )'</span>, <span class="string">'FontSize'</span>, 16, <span class="string">'Color'</span>, [1 1 1]);
        <span class="keyword">end</span>


        <span class="comment">% photocurrents SNR</span>
        subplot(<span class="string">'Position'</span>, subplotPosVectors(coneType,6).v);
        hold <span class="string">on</span>
        <span class="comment">% Identify stimulus presentation times</span>
        <span class="keyword">for</span> k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], SNRlims, <span class="string">'k-'</span>, <span class="string">'Color'</span>, [0.5 0.5 0.5]);
        <span class="keyword">end</span>
        <span class="comment">% Plot the time-varying SNR</span>
        stairs(photocurrentTime, photocurrentSNR, <span class="string">'Color'</span>, colors(coneType,:), <span class="string">'LineWidth'</span>, 1.5);
        box <span class="string">on</span>;
        set(gca, <span class="string">'XColor'</span>, [0.8 0.8 0.8], <span class="string">'YColor'</span>, [0.8 0.8 0.8], <span class="string">'Color'</span>, plotBackgroundColor, <span class="string">'FontSize'</span>, 14, <span class="string">'XLim'</span>, [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt],  <span class="string">'YLim'</span>, SNRlims, <span class="string">'YScale'</span>, <span class="string">'Linear'</span>);
        <span class="keyword">if</span> (coneType == 3)
            xlabel(<span class="string">'time (seconds)'</span>, <span class="string">'FontSize'</span>, 16);
        <span class="keyword">end</span>
        ylabel(<span class="string">'photocurrent SNR ( \mu/\sigma )'</span>, <span class="string">'FontSize'</span>, 16, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>, <span class="string">'Color'</span>, [1 1 0.3]);
        <span class="keyword">if</span> (coneType == 1)
            title(<span class="string">'SNR  ( \mu/\sigma )'</span>, <span class="string">'FontSize'</span>, 16, <span class="string">'Color'</span>, [1 1 1]);
        <span class="keyword">end</span>

        drawnow;
    <span class="keyword">end</span>

    <span class="comment">%NicePlot.exportFigToPNG(sprintf('Fig%d.png', figNo), hFig, 300);</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = v_osTimeStep(varargin)
%
% Demonstrate simulations using three different timebases, 
%    For stimuli (based on stimulus refresh rate), 
%    For absorptions and eye movements (based on coneMosaic.integrationTime)
%    For outer segment current computations (based on os.timeStep) 
%
% Mainly, we can just use the compute method of the @coneMosaic class for
% either a single image or for a sequence of oi images (oiSequence class).
%
% This script demonstrates the direct usage of the computeForOISequence()
% method of @coneMosaic. The sequence version of compute calculates
% absorptions and photocurrents for an oiSequence class of optical images
% with eye movements.
%
% NPC, ISETBIO TEAM, 2016

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
end

%% Function implementing the isetbio validation code
function ValidationFunction(runTimeParams)
%%
% The ground truth data are no longer consistent.
% This code is too long, needs some attention and simplification.

%% Init
ieInit;

% Reproduce identical random number
rng('default'); rng(1);

% Define number of response instances
instancesNum = 50; 
    
% Steady params
c0 = struct(...
    'mosaicSize', nan, ...                      % 1 L-, 1 M-, and 1 S-cone only
    'meanLuminance', 100, ...                   % scene mean luminance
    'modulationGain', 1.0, ...                  % 100%  modulation against background
    'modulationRegion', 'FULL', ...             % modulate the central image (choose b/n 'FULL', and 'CENTER')
    'stimulusSamplingInterval',  nan, ...       % we will vary this one
    'integrationTime', 10/1000, ...             % 10 msec integrationTime 
    'photonNoise', 'frozen', ...                % add Poisson noise
    'osTimeStep', 0.1/1000, ...                 % 0.1 millisecond
    'osNoise', 'frozen' ...                     % photocurrent noise
    );


% Identical stimulus sampling interval and integration time
stimulusConditionIndex = 1;
theCondition = c0;
theCondition.stimulusSamplingInterval = 10/1000;  
c{stimulusConditionIndex} = theCondition;

% Stimulus sampling interval < integration time
stimulusConditionIndex = 2;
theCondition = c0;
theCondition.stimulusSamplingInterval = 7/1000;               
c{stimulusConditionIndex} = theCondition;

% Stimulus sampling interval > integration time
stimulusConditionIndex = 3;
theCondition = c0;
theCondition.stimulusSamplingInterval = 16/1000;
c{stimulusConditionIndex} = theCondition;


for stimulusConditionIndex = 1:numel(c)
    
   [ theConeMosaic{stimulusConditionIndex}, ...
     theOIsequence{stimulusConditionIndex}, ...
     oiTimeAxis{stimulusConditionIndex}, ...
     absorptionsTimeAxis{stimulusConditionIndex}, ...
     photocurrentsTimeAxis{stimulusConditionIndex}, ...
     allInstancesAbsorptionsCountSequence{stimulusConditionIndex}, ...
     allInstancesIsomerizationRateSequence{stimulusConditionIndex}, ...
     allInstancesPhotoCurrents{stimulusConditionIndex} ...
   ] = runSimulation(c{stimulusConditionIndex}, instancesNum, runTimeParams);  

    if (runTimeParams.generatePlots)
        plotSNR(absorptionsTimeAxis{stimulusConditionIndex}, ...
            oiTimeAxis{stimulusConditionIndex}, ...
            photocurrentsTimeAxis{stimulusConditionIndex}, ...
            allInstancesAbsorptionsCountSequence{stimulusConditionIndex}, ...
            allInstancesPhotoCurrents{stimulusConditionIndex}, ...
            stimulusConditionIndex);
    end   
end


% Save validation data
% conditions data
UnitTest.validationData('condParams', c);

UnitTest.validationData('oiTimeAxisCond1', oiTimeAxis{1});
UnitTest.validationData('absorptionsTimeAxisCond1', absorptionsTimeAxis{1});
UnitTest.validationData('photoCurrentTimeAxisCond1', photocurrentsTimeAxis{1});
UnitTest.validationData('allInstancesAbsorptionsCountSequenceCond1', allInstancesAbsorptionsCountSequence{1});
UnitTest.validationData('allInstancesIsomerizationRateSequenceCond1', round(allInstancesIsomerizationRateSequence{1}, 4));
UnitTest.validationData('allInstancesPhotoCurrentsCond1', round(allInstancesPhotoCurrents{1}, 5));

UnitTest.validationData('oiTimeAxisCond2', oiTimeAxis{2});
UnitTest.validationData('absorptionsTimeAxisCond2', absorptionsTimeAxis{2});
UnitTest.validationData('photoCurrentTimeAxisCond2', photocurrentsTimeAxis{2});
UnitTest.validationData('allInstancesAbsorptionsCountSequenceCond2', allInstancesAbsorptionsCountSequence{2});
UnitTest.validationData('allInstancesIsomerizationRateSequenceCond2', round(allInstancesIsomerizationRateSequence{2}, 4));
UnitTest.validationData('allInstancesPhotoCurrentsCond2', round(allInstancesPhotoCurrents{2}, 5));

UnitTest.validationData('oiTimeAxisCond3', oiTimeAxis{3});
UnitTest.validationData('absorptionsTimeAxisCond3', absorptionsTimeAxis{3});
UnitTest.validationData('photoCurrentTimeAxisCond3', photocurrentsTimeAxis{3});
UnitTest.validationData('allInstancesAbsorptionsCountSequenceCond3', allInstancesAbsorptionsCountSequence{3});
UnitTest.validationData('allInstancesIsomerizationRateSequenceCond3', round(allInstancesIsomerizationRateSequence{3}, 4));
UnitTest.validationData('allInstancesPhotoCurrentsCond3', round(allInstancesPhotoCurrents{3}, 5));

% Extra data: coneMosaics and oiSequences
UnitTest.extraData('theConeMosaicCond1', theConeMosaic{1});
UnitTest.extraData('theOIsequenceCond1', theOIsequence{1});
UnitTest.extraData('theConeMosaicCond2', theConeMosaic{2});
UnitTest.extraData('theOIsequenceCond2', theOIsequence{2});
UnitTest.extraData('theConeMosaicCond3', theConeMosaic{3});
UnitTest.extraData('theOIsequenceCond4', theOIsequence{3});

end


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- Main computation function REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

function [theConeMosaic, theOIsequence, ...
    oiTimeAxis, absorptionsTimeAxis, photocurrentsTimeAxis, ...
    allInstancesAbsorptionsCountSequence, ...
    allInstancesIsomerizationRateSequence, ...
    allInstancesPhotoCurrents] = runSimulation(condData, instancesNum, runtimeParams)

    mosaicSize = condData.mosaicSize;
    meanLuminance = condData.meanLuminance;
    modulationGain = condData.modulationGain;
    modulationRegion = condData.modulationRegion;
    stimulusSamplingInterval = condData.stimulusSamplingInterval;
    integrationTime = condData.integrationTime;
    osTimeStep = condData.osTimeStep;
    photonNoise = condData.photonNoise; 
    osNoise = condData.osNoise;
    
    % Define the time axis for the simulation
    oiTimeAxis = 0:stimulusSamplingInterval:0.4;
    oiTimeAxis = oiTimeAxis - mean(oiTimeAxis);
    
    % Compute the stimulus modulation function
    stimulusRampTau = 0.07;
    modulationFunction = modulationGain * exp(-0.5*(oiTimeAxis/stimulusRampTau).^2);
    
    % Generate a uniform field scene with desired mean luminance
    if (isnan(mosaicSize))
        FOV = 0.2;
    else
        FOV = max(mosaicSize);
    end
    
    % Generate the scene
    theScene = uniformFieldSceneCreate(FOV, meanLuminance);

    % Generate optics
    noOptics = false;
    theOI = oiGenerate(noOptics);

    % Generate the sequence of optical images
    theOIsequence = oiSequenceGenerate(theScene, theOI, oiTimeAxis, modulationFunction, 'CENTER');
    if (runtimeParams.generatePlots)
        %theOIsequence.visualize('format', 'montage');
        theOIsequence.visualize();
    end
    
    % Generate the cone mosaic with eye movements for theOIsequence
    theConeMosaic = coneMosaicGenerate(mosaicSize, photonNoise, osNoise, integrationTime, osTimeStep);

    % Generate eye movement paths for all instances
    eyeMovementsNum = theOIsequence.maxEyeMovementsNumGivenIntegrationTime(theConeMosaic.integrationTime);
    emPaths = zeros(instancesNum, eyeMovementsNum,2);
    for instanceIndex = 1:instancesNum
        emPaths(instanceIndex, :, :) = theConeMosaic.emGenSequence(eyeMovementsNum)*0;
    end 
    
    % Compute all instances 
    [allInstancesAbsorptionsCountSequence, allInstancesPhotoCurrents] = ...
            theConeMosaic.computeForOISequence(theOIsequence, ...
            'emPaths', emPaths, ...
            'currentFlag', true);
     absorptionsTimeAxis = theConeMosaic.timeAxis + theOIsequence.timeAxis(1);
     photocurrentsTimeAxis = absorptionsTimeAxis;
     
     % Compute photon rate from photon count
     allInstancesIsomerizationRateSequence = allInstancesAbsorptionsCountSequence / theConeMosaic.integrationTime;
    
     
     % Internal consistency checks
     % Check that the data in the absorptions property agrees with the data in the last instance of allInstancesAbsorptionsCountSequence
     lastInstance = size(allInstancesAbsorptionsCountSequence,1);
     s1 = single(theConeMosaic.absorptions);
     s2 = single(reshape(squeeze(allInstancesAbsorptionsCountSequence(lastInstance,:,:,:)), [size(theConeMosaic.pattern,1) size(theConeMosaic.pattern,2) numel(absorptionsTimeAxis)]));
     
     tolerance = 1E-6;
     quantityOfInterest = s1(:)-s2(:);
     UnitTest.assertIsZero(quantityOfInterest,'coneMosaic.computeForOISequence: absorptions from coneMosaic property and returned absorptions',tolerance);
    
     % Check that the data in the current property agrees with the data in the last instance of allInstancesPhotoCurrents
     s1 = single(theConeMosaic.current);
     s2 = single(reshape(allInstancesPhotoCurrents(lastInstance,:,:,:), ...
         size(theConeMosaic.pattern,1), size(theConeMosaic.pattern,2), size(allInstancesPhotoCurrents,4)));
     
     tolerance = 1E-6;
     quantityOfInterest = s1(:)-s2(:);
     UnitTest.assertIsZero(quantityOfInterest,'coneMosaic.computeForOISequence: current from coneMosaic property and returned photocurrents',tolerance);
       
     % Compute responses for the first instance only using the coneMosaic.compute() method
     [allInstancesAbsorptionsCountSequence2, allInstancesPhotoCurrents2] = ...
            theConeMosaic.compute(theOIsequence, ...
            'emPath', emPaths(1,:,:), ...
            'currentFlag', true);
     absorptionsTimeAxis2 = theConeMosaic.timeAxis + theOIsequence.timeAxis(1);
     photocurrentsTimeAxis2 = absorptionsTimeAxis2;
     
     % Check that the data in the absorptions property agrees with the data in the last instance of allInstancesAbsorptionsCountSequence
     lastInstance = size(allInstancesAbsorptionsCountSequence2,1);
     s1 = single(theConeMosaic.absorptions);
     s2 = single(reshape(squeeze(allInstancesAbsorptionsCountSequence2(lastInstance,:,:,:)), [size(theConeMosaic.pattern,1) size(theConeMosaic.pattern,2) numel(absorptionsTimeAxis2)]));
     
     tolerance = 1E-6;
     quantityOfInterest = s1(:)-s2(:);
     UnitTest.assertIsZero(quantityOfInterest,'coneMosaic.compute: absorptions from coneMosaic property and returned absorptions',tolerance);
    
     % Check that the data in the current property agrees with the data in the last instance of allInstancesPhotoCurrents
     s1 = single(theConeMosaic.current);
     s2 = single(reshape(allInstancesPhotoCurrents2(lastInstance,:,:,:), ...
         size(theConeMosaic.pattern,1), size(theConeMosaic.pattern,2), size(allInstancesPhotoCurrents2,4)));
     
     tolerance = 1E-6;
     quantityOfInterest = s1(:)-s2(:);
     UnitTest.assertIsZero(quantityOfInterest,'coneMosaic.compute: current from coneMosaic property and returned photocurrents',tolerance);
end


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- Helper functions REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

function theConeMosaic = coneMosaicGenerate(mosaicSize, photonNoise, osNoise, integrationTime, osTimeStep)
    % Default human mosaic
    theConeMosaic = coneMosaic;
    
    % Adjust size
    if isnan(mosaicSize)
        % Generate a human cone mosaic with 1L, 1M and 1S cone
        theConeMosaic.rows = 1;
        theConeMosaic.cols = 3;
        theConeMosaic.pattern = [2 3 4];
    else
        theConeMosaic.setSizeToFOV(mosaicSize);
    end
    
    % Set the noise
    theConeMosaic.noiseFlag = photonNoise;

    % Set the integrationTime
    theConeMosaic.integrationTime = integrationTime;
    
    % Generate the outer-segment object to be used by the coneMosaic
    theOuterSegment = osLinear();
    theOuterSegment.noiseFlag = osNoise;
    
    % Set a custom timeStep, for @osLinear we do not need the default 0.1 msec
    theOuterSegment.timeStep = osTimeStep;

    % Couple the outersegment object to the cone mosaic object
    theConeMosaic.os = theOuterSegment;
end


function theOIsequence = oiSequenceGenerate(theScene, theOI, oiTimeAxis, modulationFunction, modulationType)
    % Compute the background and modulated optical images
    oiBackground = oiCompute(theOI, theScene);
    oiModulated  = oiBackground;
    
    if strcmp(modulationType, 'FULL')
        theOIsequence = oiSequence(oiBackground, oiModulated, oiTimeAxis, modulationFunction);
    else
        pos = oiGet(oiBackground, 'spatial support', 'microns');
        modulationRegion.radiusInMicrons = 0.5*max(pos(:));
        theOIsequence = oiSequence(oiBackground, oiModulated, oiTimeAxis, modulationFunction, 'modulationRegion', modulationRegion);
    end
end


function theOI = oiGenerate(noOptics)
    % Generate optics
    if (noOptics)
        theOI = oiCreate('diffraction limited');
        optics = oiGet(theOI,'optics');           
        optics = opticsSet(optics,'fnumber',0);
        optics = opticsSet(optics, 'off axis method', 'skip');
        theOI = oiSet(theOI,'optics', optics);
    else
        theOI = oiCreate('human');
    end
end


function uniformScene = uniformFieldSceneCreate(FOV, meanLuminance)
    uniformScene = sceneCreate('uniform equal photon', 128);
    % square scene with desired FOV
    uniformScene = sceneSet(uniformScene, 'wAngular', FOV);
    % 1 meter away
    uniformScene = sceneSet(uniformScene, 'distance', 1.0);
    % adjust radiance according to desired  mean luminance
    uniformScene = sceneAdjustLuminance(uniformScene, meanLuminance);
end


% REPLACE_WITH_DASH_DASH- Plotting function REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

function plotSNR(isomerizationsTimeAxis, oiTimeAxis, photocurrentTime, allInstancesIsomerizationsCount, allInstancesPhotoCurrents, figNo)
    
    % Compute isomerization means and stds across all instances
    isomerizationMeans = mean(allInstancesIsomerizationsCount, 1);
    isomerizationSTDs = std(allInstancesIsomerizationsCount, 0, 1);
    
    % Subtract baseline from all photocurrents
    normalizePhotocurrents = true;
    if (normalizePhotocurrents)
        minLMS = squeeze(min(min(min(allInstancesPhotoCurrents,[],1), [],2), [], 4));
        photocurrentBaseline = ones(size(allInstancesPhotoCurrents));
        for coneIndex = 1:3
            photocurrentBaseline(:,:,coneIndex,:) = minLMS(coneIndex);
        end
        photocurrentRange = [0 60];
    else
        photocurrentBaseline = allInstancesPhotoCurrents(:,:,:,1)*0;
        photocurrentBaseline = reshape(photocurrentBaseline, [size(allInstancesPhotoCurrents,1) size(allInstancesPhotoCurrents,2) size(allInstancesPhotoCurrents,3) 1]);
        photocurrentRange = [min(allInstancesPhotoCurrents(:)) max(allInstancesPhotoCurrents(:))];
        
    end
    allInstancesPhotoCurrents = bsxfun(@minus, allInstancesPhotoCurrents, photocurrentBaseline); 
    
    
    % compute photocurrent means and stds across all instances
    photocurrentMeansBaselineCorrected  = mean(allInstancesPhotoCurrents,1);
    photocurrentSTDsBaselineCorrected   = std(allInstancesPhotoCurrents, 0, 1);
    
    
    dt = isomerizationsTimeAxis(2)-isomerizationsTimeAxis(1);
    instancesNum = size(allInstancesIsomerizationsCount,1);
    % Plotting limits
    absorptionsFanoFactorLims = [0.0 10];
    photocurrentFanoFactorLims = [0.0 10];
    SNRlims = [0 60];
      
    hFig = figure(figNo+1000); clf;
    set(hFig, 'Position', [10+figNo*10 10 1800 1180], 'Color', [0 0 0]);
    
    colors = [1 0 0; 0 1.0 0; 0 0.8 1];
    coneNames = {'L-cone', 'M-cone', 'S-cone'};
    
    subplotPosVectors = NicePlot.getSubPlotPosVectors(...
           'rowsNum', 3, ...
           'colsNum', 6, ...
           'heightMargin',   0.04, ...
           'widthMargin',    0.05, ...
           'leftMargin',     0.05, ...
           'rightMargin',    0.00, ...
           'bottomMargin',   0.04, ...
           'topMargin',      0.04);
    
    for coneType = 1:3

        mu = squeeze(isomerizationMeans(1,1, coneType,:));
        sigma = squeeze(isomerizationSTDs(1,1, coneType,:));
        % avoid divisions by zero
        sigma(mu == 0) = 1;
        
        variance = sigma.^2;
        isomerizationsInverseFanoFactor = mu ./ variance;
        isomerizationsSNR = mu ./sigma;
        
        mu = squeeze(photocurrentMeansBaselineCorrected(1,1,coneType,:));
        sigma = squeeze(photocurrentSTDsBaselineCorrected(1,1,coneType,:));
        % avoid divisions by near zero by making very small photocurrents = 0
        sigma(mu < 0.1) = 1;
        mu(mu < 0.1) = 0;
        
        variance = sigma.^2;
        photocurrentInverseFanoFactor = mu ./variance;
        photocurrentSNR = mu ./ sigma;
        
        maxIsomerizationCountForThisCone = max(max(max(squeeze(allInstancesIsomerizationsCount(:,:,coneType,:))))) + 1;
        minIsomerizationCountForThisCone = min(min(min(squeeze(allInstancesIsomerizationsCount(:,:, coneType,:)))));
        
        plotBackgroundColor = [0.1 0.1 0.1];
        
        % Absorption events
        subplot('Position', subplotPosVectors(coneType,1).v);
        hold on
        % Identify stimulus presentation times
        for k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], [minIsomerizationCountForThisCone maxIsomerizationCountForThisCone], 'k-', 'Color', [0.5 0.5 0.5]);
        end
        
        barOpacity = 0.25;
        for tIndex = 1:numel(isomerizationsTimeAxis)
            quantaAtThisTimeBin = squeeze(allInstancesIsomerizationsCount(:,1, coneType,tIndex));
            plot([isomerizationsTimeAxis(tIndex) isomerizationsTimeAxis(tIndex)+dt], [quantaAtThisTimeBin(:) quantaAtThisTimeBin(:)], '-', 'LineWidth', 1.5, 'Color', [colors(coneType,:) barOpacity]);
        end
        box on;
        set(gca, 'XColor', [0.8 0.8 0.8], 'YColor', [0.8 0.8 0.8], 'Color', plotBackgroundColor, 'FontSize', 14, 'XLim', [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt], 'YLim', [minIsomerizationCountForThisCone maxIsomerizationCountForThisCone]);
        if (coneType == 3)
            xlabel('time (seconds)', 'FontSize', 16);
        end
        ylabel(sprintf('%s isomerizations in %2.1f msec', coneNames{coneType}, 1000*dt), 'FontSize', 16, 'FontWeight', 'bold', 'Color', [1 1 0.3]);
        if (coneType == 1)
            title(sprintf('isomerizations\n(%d instances)', instancesNum), 'FontSize', 16, 'Color', [1 1 1]);
        end
        
        
        
        % Absorptions InverseFanoFactor
        subplot('Position', subplotPosVectors(coneType,2).v);
        hold on
        % Identify stimulus presentation times
        for k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], absorptionsFanoFactorLims, 'k-', 'Color', [0.5 0.5 0.5]);
        end
        % Identify the FanoFactor = 1 line
        plot([isomerizationsTimeAxis isomerizationsTimeAxis(end)+dt], [ones(size(isomerizationsTimeAxis)) 1], 'REPLACE_WITH_DASH_DASH', 'Color', [0.8 0.8 0.3], 'LineWidth', 1.5);
        % Plot the time-varying Fano factor
        for tIndex = 1:numel(isomerizationsTimeAxis)
            if (tIndex < numel(isomerizationsTimeAxis))
                xx = [isomerizationsTimeAxis(tIndex) isomerizationsTimeAxis(tIndex)+dt isomerizationsTimeAxis(tIndex+1)];
                yy = [isomerizationsInverseFanoFactor(tIndex) * [1 1] isomerizationsInverseFanoFactor(tIndex+1)];
            else
                xx = [isomerizationsTimeAxis(tIndex) isomerizationsTimeAxis(tIndex)+dt];
                yy = isomerizationsInverseFanoFactor(tIndex) * [1 1];
            end
            plot(xx,yy, '-', 'Color', colors(coneType,:), 'LineWidth', 1.5);
        end
        box on;
        yTicks = [0 1 2 4 8];
        set(gca, 'XColor', [0.8 0.8 0.8], 'YColor', [0.8 0.8 0.8], 'Color', plotBackgroundColor, 'FontSize', 14, 'XLim', [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt], 'YLim', absorptionsFanoFactorLims, 'YScale', 'Linear', 'YTick', yTicks, 'YTickLabel', sprintf('%2.2f\n', yTicks));
        if (coneType == 3)
            xlabel('time (seconds)', 'FontSize', 16);
        end
        ylabel('quanta inverse Fano factor ( \mu/{\sigma}^2 )', 'FontSize', 16, 'FontWeight', 'bold', 'Color', [1 1 0.3]);
        if (coneType == 1)
            title('Inv. Fano Factor ( \mu/{\sigma}^2 )', 'FontSize', 16, 'Color', [1 1 1]);
        end
        
        % Absorptions SNR
        subplot('Position', subplotPosVectors(coneType,3).v);
        hold on
        % Identify stimulus presentation times
        for k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], SNRlims, 'k-', 'Color', [0.5 0.5 0.5]);
        end
        % Plot the time-varying SNR
        for tIndex = 1:numel(isomerizationsTimeAxis)
            if (tIndex < numel(isomerizationsTimeAxis))
                xx = [isomerizationsTimeAxis(tIndex) isomerizationsTimeAxis(tIndex)+dt isomerizationsTimeAxis(tIndex+1)];
                yy = [isomerizationsSNR(tIndex) * [1 1] isomerizationsSNR(tIndex+1)];
            else
                xx = [isomerizationsTimeAxis(tIndex) isomerizationsTimeAxis(tIndex)+dt];
                yy = isomerizationsSNR(tIndex) * [1 1];
            end
            plot(xx,yy, '-', 'Color', colors(coneType,:), 'LineWidth', 1.5);
        end
        box on;
        set(gca, 'XColor', [0.8 0.8 0.8], 'YColor', [0.8 0.8 0.8], 'Color', plotBackgroundColor, 'FontSize', 14, 'XLim', [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt],  'YLim', SNRlims, 'YScale', 'Linear');
        if (coneType == 3)
            xlabel('time (seconds)', 'FontSize', 16);
        end
        ylabel('quanta SNR ( \mu/\sigma )', 'FontSize', 16, 'FontWeight', 'bold', 'Color', [1 1 0.3]);
        if (coneType == 1)
            title('SNR ( \mu/\sigma )', 'FontSize', 16, 'Color', [1 1 1]);
        end
        
        
        % photocurrents
        subplot('Position', subplotPosVectors(coneType,4).v);
        % Identify stimulus presentation times
        hold on
        for k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], photocurrentRange, 'k-', 'Color', [0.5 0.5 0.5]);
        end
        
        % Plot photocurrents
        plot(photocurrentTime, squeeze(allInstancesPhotoCurrents(:,1,coneType, :)), 'LineWidth', 1.5, 'Color', [colors(coneType,:) barOpacity*2]);
        box on;
        set(gca, 'XColor', [0.8 0.8 0.8], 'YColor', [0.8 0.8 0.8], 'Color', plotBackgroundColor, 'FontSize', 14, 'XLim', [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt], 'YLim', photocurrentRange);
        if (coneType == 3)
            xlabel('time (seconds)', 'FontSize', 16);
        end
        ylabel('photocurrent (pA)', 'FontSize', 16, 'FontWeight', 'bold', 'Color', [1 1 0.3]);
        if (coneType == 1)
            title(sprintf('pcurrent, os.noiseFlag=false\n (%d instances)', instancesNum), 'FontSize', 16, 'Color', [1 1 1]);
        end

        % Photocurrent time-varying inverse FanoFactor
        
        subplot('Position', subplotPosVectors(coneType,5).v);
        hold on
        % Identify stimulus presentation times
        for k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], photocurrentFanoFactorLims, 'k-', 'Color', [0.5 0.5 0.5]);
        end
        % Identify the FanoFactor = 1 line
        plot([photocurrentTime photocurrentTime(end)], [ones(size(photocurrentTime)) 1], 'REPLACE_WITH_DASH_DASH', 'Color', [0.8 0.8 0.3], 'LineWidth', 1.5);
        % Plot the time-varying Fano factor
        stairs(photocurrentTime, photocurrentInverseFanoFactor, 'Color', colors(coneType,:), 'LineWidth', 1.5);
        box on;
        yTicks = [0 1 2 4 8];
        set(gca, 'XColor', [0.8 0.8 0.8], 'YColor', [0.8 0.8 0.8], 'Color', plotBackgroundColor, 'FontSize', 14, 'XLim', [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt], 'YLim', photocurrentFanoFactorLims, 'YScale', 'Linear', 'YTick', yTicks, 'YTickLabel', sprintf('%2.2f\n', yTicks));
        if (coneType == 3)
            xlabel('time (seconds)', 'FontSize', 16);
        end
        ylabel('photocurrent Inverse Fano factor ( \mu/{\sigma}^2 )', 'FontSize', 16, 'FontWeight', 'bold', 'Color', [1 1 0.3]);
        if (coneType == 1)
            title('Inv. Fano Factor ( \mu/{\sigma}^2 )', 'FontSize', 16, 'Color', [1 1 1]);
        end
        
        
        % photocurrents SNR
        subplot('Position', subplotPosVectors(coneType,6).v);
        hold on
        % Identify stimulus presentation times
        for k = 1:numel(oiTimeAxis)
            plot(oiTimeAxis(k)*[1 1], SNRlims, 'k-', 'Color', [0.5 0.5 0.5]);
        end
        % Plot the time-varying SNR
        stairs(photocurrentTime, photocurrentSNR, 'Color', colors(coneType,:), 'LineWidth', 1.5);
        box on;
        set(gca, 'XColor', [0.8 0.8 0.8], 'YColor', [0.8 0.8 0.8], 'Color', plotBackgroundColor, 'FontSize', 14, 'XLim', [isomerizationsTimeAxis(1) isomerizationsTimeAxis(end)+dt],  'YLim', SNRlims, 'YScale', 'Linear');
        if (coneType == 3)
            xlabel('time (seconds)', 'FontSize', 16);
        end
        ylabel('photocurrent SNR ( \mu/\sigma )', 'FontSize', 16, 'FontWeight', 'bold', 'Color', [1 1 0.3]);
        if (coneType == 1)
            title('SNR  ( \mu/\sigma )', 'FontSize', 16, 'Color', [1 1 1]);
        end
        
        drawnow;
    end
    
    %NicePlot.exportFigToPNG(sprintf('Fig%d.png', figNo), hFig, 300);
end
##### SOURCE END #####
--></body></html>