
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>v_DisplayColorConversion</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-04-14"><meta name="DC.source" content="v_DisplayColorConversion.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Function implementing the isetbio validation code</a></li><li><a href="#4">Initialize ISET</a></li><li><a href="#5">Some informative text</a></li><li><a href="#6">Remove the Brainard lab PTB overrides folder from the path</a></li><li><a href="#7">Overview</a></li><li><a href="#8">Create isetbio display</a></li><li><a href="#9">Create a uniform field radiance image in ISETBIO</a></li><li><a href="#10">Compute optial image, for delta function optics.</a></li><li><a href="#11">Compute sensor image</a></li><li><a href="#12">Get the LMS isomerization rates out of the sensor image</a></li><li><a href="#13">Get cone fundamentals that ISETBIO is using, for use with PTB routines.</a></li><li><a href="#14">Create PTB calibration structure from ISETBIO display object</a></li><li><a href="#15">Initialize PTB calibration structure.</a></li><li><a href="#16">Compare PTB and ISETBIO LUT inversion</a></li><li><a href="#17">Easy to check if PTB LUT inversion is invertible</a></li><li><a href="#18">Compare irradiance in optical image with that computed directly from the primaries</a></li><li><a href="#19">PTB conversion to isomerization rates</a></li><li><a href="#20">Compare the two methods.</a></li><li><a href="#22">Restore original path</a></li><li><a href="#23">Save validation operations</a></li><li><a href="#24">Plot</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = v_DisplayColorConversion(varargin)
<span class="comment">%</span>
<span class="comment">% Validate display calibration color conversion against PTB.  Oddly enough,</span>
<span class="comment">% this also does some checking of LUT inversion.</span>
<span class="comment">%</span>
<span class="comment">% ISETBIO and PTB agree well on this calculation.</span>
<span class="comment">%</span>
<span class="comment">% See also v_IrradianceIsomerizations, v_DisplayLUTInversion</span>

varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
<span class="keyword">end</span>
</pre><h2>Function implementing the isetbio validation code<a name="2"></a></h2><pre class="codeinput"><span class="keyword">function</span> ValidationFunction(runTimeParams)
</pre><h2>Initialize ISET<a name="4"></a></h2><pre class="codeinput">close <span class="string">all</span>; ieInit;
</pre><h2>Some informative text<a name="5"></a></h2><pre class="codeinput">UnitTest.validationRecord(<span class="string">'SIMPLE_MESSAGE'</span>, <span class="string">'Compare isetbio and PTB display color conversion.'</span>);
</pre><h2>Remove the Brainard lab PTB overrides folder from the path<a name="6"></a></h2><p>This prevents this code from using the new BL object oriented PTB overrides.  We could include these inside of isetbio, but the risk is that whether this program worked or not would depend on whether isetbio was before or after PTB on the user's path, something we don't want to have to deal with.  Elsewhere (not in isetbio), we have established that the PTB and BrainardLab routines do the same thing (which is not surprising, as the actual calculations are done by the same underlying code in each case, just accessed differently.)</p><pre class="codeinput"><span class="comment">%[removedFolderFromCurrentPath, originalPath] = removeBrainardLabPTBOverrides();</span>

<span class="comment">% new script (is there an other one, here ?)</span>

<span class="keyword">try</span>
</pre><h2>Overview<a name="7"></a></h2><p>What we are going to do in this script is to create uniform field corresponding to specified display and rgb values and pump it through isetbio to get cone isomerization rates.  Then we are going to do the calculation for the same display, cone fundamentals, and rgb values in PTB.  We start with the isetbio calculation.</p><h2>Create isetbio display<a name="8"></a></h2><pre class="codeinput">    displayToTest = <span class="string">'LCD-Apple'</span>;
    d = displayCreate(displayToTest);
    gammaTable = displayGet(d, <span class="string">'gamma table'</span>);
    <span class="keyword">if</span> (size(gammaTable,2) ~=  3)
        error(<span class="string">'Cannot deal with a display that has other than 3 primaries for this test.'</span>);
    <span class="keyword">end</span>
    nInputLevels = size(gammaTable,1);
</pre><h2>Create a uniform field radiance image in ISETBIO<a name="9"></a></h2><p>Use the display object and the passed RGB values.</p><p>The assumption here is that isetbio uses the display depth to figure out how to convert integers to the right input for gamma correction.</p><p>ISETBIO displays work with integer display inputs, which makes the bit depth explicit but which require that you keep track of the bit depth carefully.</p><p>PTB works in a world where displays are driven with [0-1] real numbers -- this is how OpenGL works, with the display driver responsible for digitizing. This keeps the code very portable but does make it hard to know the bit depth.</p><p>Choose RGB values in the range where the different gamma correction methods used by ISETBIO and PTB agree (see v_DisplayLUTInversion).</p><pre class="codeinput">    RGBToTest = [0.3 0.73 0.42]';
    <span class="comment">%RGBToTest = [1 1 1]';</span>
    theRGBImage = ones(20,20,3);
    <span class="keyword">for</span> i1 = 1:3
        theRGBImage(:,:,i1) = round((nInputLevels-1)*RGBToTest(i1));
    <span class="keyword">end</span>
    sceneDegrees = 10;  <span class="comment">% need large field</span>
    scene = sceneFromFile(theRGBImage,<span class="string">'rgb'</span>,[],d);
    scene = sceneSet(scene,<span class="string">'fov'</span>, sceneDegrees);
    sceneSize = sceneGet(scene,<span class="string">'size'</span>);
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        vcAddAndSelectObject(scene); sceneWindow;
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="v_DisplayColorConversion_01.png" alt=""> <h2>Compute optial image, for delta function optics.<a name="10"></a></h2><pre class="codeinput">    oi = oiCreate(<span class="string">'human'</span>);
    optics = oiGet(oi,<span class="string">'optics'</span>);
    optics = opticsSet(optics,<span class="string">'off axis method'</span>,<span class="string">'skip'</span>);
    optics = opticsSet(optics,<span class="string">'otf method'</span>,<span class="string">'skip otf'</span>);
    oi = oiSet(oi,<span class="string">'optics'</span>,optics);
    oi = oiCompute(scene,oi);
    oi = oiSet(oi,<span class="string">'fov'</span>,sceneDegrees);
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        vcAddAndSelectObject(oi); oiWindow;
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="v_DisplayColorConversion_02.png" alt=""> <h2>Compute sensor image<a name="11"></a></h2><p>Integration time is set to 1 second, so this comes out as isomserizations per second.  The run without photon/shot noise, so that the comparison will not be stochastic.</p><pre class="codeinput">    sensorDegrees = 2;
    roiPixels = 10;
    sensor = sensorCreate(<span class="string">'human'</span>);
    sensor = sensorSet(sensor,<span class="string">'wave'</span>,displayGet(d,<span class="string">'wave'</span>));
    sensor = sensorSet(sensor, <span class="string">'noise flag'</span>, 0);
    sensor = sensorSet(sensor,<span class="string">'exp time'</span>,1);
    sensor = sensorSet(sensor,<span class="string">'rows'</span>,128);
    sensor = sensorSet(sensor,<span class="string">'cols'</span>,128);
    [sensor, ~] = sensorSetSizeToFOV(sensor,sensorDegrees,scene,oi);
    sensor = sensorCompute(sensor,oi);
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        vcAddAndSelectObject(sensor); sensorWindow(<span class="string">'scale'</span>,1);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="v_DisplayColorConversion_03.png" alt=""> <h2>Get the LMS isomerization rates out of the sensor image<a name="12"></a></h2><p>Pull out responses of each cone type within ROI. I am doing this by brute force, because I can't find quite the right combination of ROI gets from the sensor image.</p><pre class="codeinput">    isetbioIsomerizationsArray = sensorGet(sensor,<span class="string">'photons'</span>);
    sensorCFA = sensorGet(sensor,<span class="string">'cfa'</span>);
    sensorSizePixels = sensorGet(sensor,<span class="string">'size'</span>);
    rect = round([sensorSizePixels(2)/2,sensorSizePixels(1)/2,roiPixels,roiPixels]);
    sensorRoiLocs = ieRoi2Locs(rect);
    nLocs = size(sensorRoiLocs,1);
    sumIsomerizations = zeros(3,1);
    nSummed = zeros(3,1);
    <span class="keyword">for</span> jj = 1:nLocs
        <span class="comment">% A type of 1 in the CFA is blank, so we subtract 1 from the number</span>
        <span class="comment">% in the CFA and skip any that end up as 0.  This is just one of</span>
        <span class="comment">% those things about ISETBIO that you have to know.</span>
        coneType = sensorCFA.pattern(sensorRoiLocs(jj,1),sensorRoiLocs(jj,2))-1;
        <span class="keyword">if</span> (coneType &gt; 0)
            sumIsomerizations(coneType) = sumIsomerizations(coneType)+isetbioIsomerizationsArray(sensorRoiLocs(jj,1),sensorRoiLocs(jj,2));
            nSummed(coneType) = nSummed(coneType) + 1;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    isetbioLMSIsomerizations = sumIsomerizations ./ nSummed;
</pre><h2>Get cone fundamentals that ISETBIO is using, for use with PTB routines.<a name="13"></a></h2><p>Get cone fundamentals out of isetbio sensor.  We keep these as quantal efficiencies, because it is easier to think about how light produces isomerizations if we work in quantal units.</p><pre class="codeinput">    S_cones = WlsToS(sensorGet(sensor,<span class="string">'wave'</span>));
    T_conesQE = sensorGet(sensor,<span class="string">'spectral qe'</span>)';
    T_conesQE = T_conesQE(2:4,:);
</pre><h2>Create PTB calibration structure from ISETBIO display object<a name="14"></a></h2><p>Specify parameters.  Screen dot pitch and pixel size have no effect on this comparison, but we make something up just to remind us of how to do this in the display to cal conversion should we ever be looking here to figure it out.</p><pre class="codeinput">    wave = displayGet(d, <span class="string">'wave'</span>);
    isetbioPrimarySpdRadianceEnergy  = displayGet(d, <span class="string">'spd primaries'</span>);
    dotsPerMeter = displayGet(d, <span class="string">'dots per meter'</span>);
    screenSizeInPixels = [1920 1080];

    <span class="comment">% Convert primaries from radiance to retinal irradiance</span>
    <span class="comment">% Adjust for difference in isetbio and PTB wavelength sampling</span>
    <span class="comment">% conventions, and take assume pupil size into account.</span>
    <span class="comment">%</span>
    <span class="comment">% I believe the area units here are meters^2, as that tends to</span>
    <span class="comment">% be the ISETBIO default.</span>
    pupilDiameterMeters  = opticsGet(optics,<span class="string">'pupil diameter'</span>,<span class="string">'m'</span>);
    pupilAreaMeters2 = pi*(pupilDiameterMeters/2)^2;
    eyeLengthMeters = opticsGet(optics,<span class="string">'focal length'</span>,<span class="string">'m'</span>);
    ptbPrimarySpdIrradianceEnergy = RadianceAndPupilAreaEyeLengthToRetIrradiance(isetbioPrimarySpdRadianceEnergy,WlsToS(wave),pupilAreaMeters2,eyeLengthMeters);
    ptbPrimarySpdIrradianceEnergy = ptbPrimarySpdIrradianceEnergy*(wave(2)-wave(1));
    ptbPrimarySpdIrradiancePhotons = EnergyToQuanta(SToWls(wave),ptbPrimarySpdIrradianceEnergy);

    <span class="comment">% Correct for differences in the way visual angle is computed in</span>
    <span class="comment">% ISETBIO versus PTB.  See v_IrradianceIsomerizations for (a little)</span>
    <span class="comment">% more on this point.</span>
    m = opticsGet(optics,<span class="string">'magnification'</span>,sceneGet(scene,<span class="string">'distance'</span>));
    ptbPrimarySpdMagCorrectIrradiancePhotons = ptbPrimarySpdIrradiancePhotons/(1+abs(m))^2;

    <span class="comment">% Put into PTB cal structure</span>
    PTBcal = ptb.GeneratePsychToolboxCalStruct(<span class="keyword">...</span>
        <span class="string">'name'</span>, displayGet(d, <span class="string">'name'</span>), <span class="keyword">...</span>
        <span class="string">'gammaTable'</span>, gammaTable, <span class="keyword">...</span>
        <span class="string">'wave'</span>, wave, <span class="keyword">...</span>
        <span class="string">'spd'</span>, ptbPrimarySpdMagCorrectIrradiancePhotons, <span class="keyword">...</span>
        <span class="string">'screenSizeInPixels'</span>, screenSizeInPixels, <span class="keyword">...</span>
        <span class="string">'dotsPerMeter'</span>, dotsPerMeter <span class="keyword">...</span>
        );

    <span class="comment">% Kluge.  Should set this properly in creation routine.  It might even</span>
    <span class="comment">% be possible to do so, I'm not sure and the documentation in the</span>
    <span class="comment">% function is not clear on what the options are (as there is no</span>
    <span class="comment">% documentation at all, sigh.)</span>
    PTBcal.P_ambient = zeros(length(wave),1);
</pre><h2>Initialize PTB calibration structure.<a name="15"></a></h2><pre class="codeinput">    PTBcal = CalibrateFitGamma(PTBcal, nInputLevels);
    gammaMethod = 1;
    PTBcal = SetGammaMethod(PTBcal, gammaMethod, nInputLevels);
    PTBcal = SetSensorColorSpace(PTBcal,T_conesQE,S_cones);
</pre><pre class="codeoutput">Fitting with linear interpolation
</pre><h2>Compare PTB and ISETBIO LUT inversion<a name="16"></a></h2><p>These agree well, and match up with the plotted gamma table</p><pre class="codeinput">    ptbRGBToTestPrimary = SettingsToPrimary(PTBcal,RGBToTest);
    isetbioRGBToTestPrimary = ieLUTDigital(theRGBImage(1,1,:),gammaTable);
    xVals = linspace(0,1,size(gammaTable,1))';
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        figure; hold <span class="string">on</span>;
        plot(xVals,gammaTable(:,1),<span class="string">'r'</span>);
        plot(xVals,gammaTable(:,2),<span class="string">'g'</span>);
        plot(xVals,gammaTable(:,3),<span class="string">'b'</span>);
        plot([RGBToTest(1)],[ptbRGBToTestPrimary(1)],<span class="string">'ro'</span>,<span class="string">'MarkerSize'</span>,4,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>);
        plot([RGBToTest(1)],[isetbioRGBToTestPrimary(1)],<span class="string">'rx'</span>,<span class="string">'MarkerSize'</span>,6,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>);
        plot([RGBToTest(2)],[ptbRGBToTestPrimary(2)],<span class="string">'go'</span>,<span class="string">'MarkerSize'</span>,4,<span class="string">'MarkerFaceColor'</span>,<span class="string">'g'</span>);
        plot([RGBToTest(2)],[isetbioRGBToTestPrimary(2)],<span class="string">'gx'</span>,<span class="string">'MarkerSize'</span>,6,<span class="string">'MarkerFaceColor'</span>,<span class="string">'g'</span>);
        plot([RGBToTest(3)],[ptbRGBToTestPrimary(3)],<span class="string">'bo'</span>,<span class="string">'MarkerSize'</span>,4,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>);
        plot([RGBToTest(3)],[isetbioRGBToTestPrimary(3)],<span class="string">'bx'</span>,<span class="string">'MarkerSize'</span>,6,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>);
        xlabel(<span class="string">'Input channel value (normalized 0-1)'</span>);
        ylabel(<span class="string">'Output channel value (normalized 0-1)'</span>);
    <span class="keyword">end</span>
    tolerance = 0.001;
    UnitTest.assertIsZero(abs(ptbRGBToTestPrimary(1)-isetbioRGBToTestPrimary(1)),<span class="string">'Red inversion comparison'</span>,tolerance);
    UnitTest.assertIsZero(abs(ptbRGBToTestPrimary(2)-isetbioRGBToTestPrimary(2)),<span class="string">'Green inversion comparison'</span>,tolerance);
    UnitTest.assertIsZero(abs(ptbRGBToTestPrimary(3)-isetbioRGBToTestPrimary(3)),<span class="string">'Blue inversion comparison'</span>,tolerance);
</pre><img vspace="5" hspace="5" src="v_DisplayColorConversion_04.png" alt=""> <h2>Easy to check if PTB LUT inversion is invertible<a name="17"></a></h2><pre class="codeinput">    ptbRGBToTestCheck = PrimaryToSettings(PTBcal,ptbRGBToTestPrimary);
    tolerance = 0.001;
    UnitTest.assertIsZero(abs(ptbRGBToTestCheck(1)-RGBToTest(1)),<span class="string">'PTB red settings-&gt;primary-&gt;settings check'</span>,tolerance);
    UnitTest.assertIsZero(abs(ptbRGBToTestCheck(2)-RGBToTest(2)),<span class="string">'PTB green settings-&gt;primary-&gt;settings check'</span>,tolerance);
    UnitTest.assertIsZero(abs(ptbRGBToTestCheck(3)-RGBToTest(3)),<span class="string">'PTB blue settings-&gt;primary-&gt;settings check'</span>,tolerance);
</pre><h2>Compare irradiance in optical image with that computed directly from the primaries<a name="18"></a></h2><p>First grab irradiance out of the optical image. Then construct spd using the primaries above and the PTB primary settings, obtained above using PTB lut inversion.</p><pre class="codeinput">    rect = [sceneSize(2)/2,sceneSize(1)/2,roiPixels,roiPixels];
    roiRoiLocs = ieRoi2Locs(rect);
    isetbioIrradianceSpdPhotons  = oiGet(oi,<span class="string">'roi mean photons'</span>,  roiRoiLocs);
    ptbIrradianceSpdPhotons = ptbPrimarySpdMagCorrectIrradiancePhotons*ptbRGBToTestPrimary;
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        figure; clf; hold <span class="string">on</span>;
        plot(wave,ptbIrradianceSpdPhotons./(wave(2)-wave(1)),<span class="string">'r'</span>);
        plot(wave,isetbioIrradianceSpdPhotons,<span class="string">'g'</span>);
        xlabel(<span class="string">'Wavelength (nm)'</span>);
        ylabel(<span class="string">'Irradiance (quanta/[sec-m2]'</span>);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="v_DisplayColorConversion_05.png" alt=""> <h2>PTB conversion to isomerization rates<a name="19"></a></h2><p>This gives isomerization rates for a cone with a collecting area of one square meter.</p><pre class="codeinput">    ptbLMSIsomerizationsRaw = SettingsToSensor(PTBcal,RGBToTest);

    <span class="comment">% Adjust by cone size used in isetbio</span>
    pixel = sensorGet(sensor,<span class="string">'pixel'</span>);
    sensorHeight = pixelGet(pixel,<span class="string">'height'</span>);
    sensorWidth = pixelGet(pixel,<span class="string">'width'</span>);
    sensorArea = sensorHeight*sensorWidth;
    ptbLMSIsomerizations = sensorArea*ptbLMSIsomerizationsRaw;
</pre><h2>Compare the two methods.<a name="20"></a></h2><p>Agreement is better than 1%</p><pre class="codeinput">    isomerizationRatios = ptbLMSIsomerizations ./ isetbioLMSIsomerizations;
    fprintf(<span class="string">'PTB/ISETBIO LMS isomerization ratios: %0.3f, %0.3f, %0.3f\n'</span>,isomerizationRatios(1),isomerizationRatios(2),isomerizationRatios(3));
    tolerance = 0.01;
    UnitTest.assertIsZero(abs(isomerizationRatios(1)-1),<span class="string">'L isomerization comparison'</span>,tolerance);
    UnitTest.assertIsZero(abs(isomerizationRatios(2)-1),<span class="string">'M isomerization comparison'</span>,tolerance);
    UnitTest.assertIsZero(abs(isomerizationRatios(3)-1),<span class="string">'S isomerization comparison'</span>,tolerance);

    <span class="comment">% Log the data</span>
    dataStruct = struct( <span class="keyword">...</span>
        <span class="string">'ptbIrradianceSpdPhotons'</span>,ptbIrradianceSpdPhotons, <span class="keyword">...</span>
        <span class="string">'isetbioIrradianceSpdPhotons'</span>,isetbioIrradianceSpdPhotons, <span class="keyword">...</span>
        <span class="string">'RGBToTest'</span>,RGBToTest, <span class="keyword">...</span>
        <span class="string">'ptbRGBToTestPrimary'</span>,ptbRGBToTestPrimary, <span class="keyword">...</span>
        <span class="string">'ptbRGBToTestCheck'</span>,ptbRGBToTestCheck, <span class="keyword">...</span>
        <span class="string">'isetbioRGBToTestPrimary'</span>,isetbioRGBToTestPrimary, <span class="keyword">...</span>
        <span class="string">'ptbLMSIsomerizations'</span>, ptbLMSIsomerizations, <span class="keyword">...</span>
        <span class="string">'isetbioLMSIsomerizations'</span>, isetbioLMSIsomerizations <span class="keyword">...</span>
        );
</pre><pre class="codeoutput">PTB/ISETBIO LMS isomerization ratios: 1.007, 1.007, 1.009
</pre><pre class="codeinput"><span class="keyword">catch</span> err
    <span class="comment">% Restore original path and rethrow error</span>
    <span class="keyword">if</span> (~isempty(removedFolderFromCurrentPath))
        path(originalPath);
    <span class="keyword">end</span>
    rethrow(err);
<span class="keyword">end</span>
</pre><h2>Restore original path<a name="22"></a></h2><pre class="codeinput"><span class="comment">%if (~isempty(removedFolderFromCurrentPath))</span>
<span class="comment">%    path(originalPath);</span>
<span class="comment">%end</span>
</pre><h2>Save validation operations<a name="23"></a></h2><pre class="codeinput">UnitTest.validationData(<span class="string">'conversionData'</span>, dataStruct);
</pre><h2>Plot<a name="24"></a></h2><pre class="codeinput"><span class="keyword">if</span> (runTimeParams.generatePlots)

<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="comment">% Helper method to remove the BrainardLabPTBOverrides folder if it exists on the current path.</span>
<span class="comment">% We want to remove this override, so we can use the original PTB functions</span>
<span class="comment">% without the CalStructOBJ (which is found only on our computers).</span>
<span class="keyword">function</span> [removedFolderFromCurrentPath, originalPath] = removeBrainardLabPTBOverrides

removedFolderFromCurrentPath = <span class="string">''</span>;
originalPath = path;

<span class="comment">% Folder to remove the Overrides/PTB-3 folder from the current path, if the folder exists on the path</span>
PTBoverridesDirToRemoveFromPath = <span class="string">'/Users/Shared/Matlab/Toolboxes/BrainardLabToolbox/Overrides/PTB-3'</span>;

<span class="comment">% determine if the PTBoverridesDirToRemoveFromPath is in the current path,</span>
<span class="comment">% and if it is remove it.</span>
pathCell = regexp(path, pathsep, <span class="string">'split'</span>);
<span class="keyword">for</span> k = 1:numel(pathCell)
  <span class="comment">% fprintf('[%d] = %s\n', k, pathCell{k});</span>
   <span class="keyword">if</span> (strncmpi(pathCell{k}, PTBoverridesDirToRemoveFromPath, numel(PTBoverridesDirToRemoveFromPath)))
       rmpath(pathCell{k});
       removedFolderFromCurrentPath{numel(removedFolderFromCurrentPath)+1} = pathCell{k};
       fprintf(<span class="string">'Found ''%s'' path in entry %d. Removing it from the path.\n'</span>, pathCell{k},k);
   <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = v_DisplayColorConversion(varargin)
%
% Validate display calibration color conversion against PTB.  Oddly enough,
% this also does some checking of LUT inversion.
%
% ISETBIO and PTB agree well on this calculation.
%
% See also v_IrradianceIsomerizations, v_DisplayLUTInversion

varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
end

%% Function implementing the isetbio validation code
function ValidationFunction(runTimeParams)

%% Initialize ISET
close all; ieInit;

%% Some informative text
UnitTest.validationRecord('SIMPLE_MESSAGE', 'Compare isetbio and PTB display color conversion.');

%% Remove the Brainard lab PTB overrides folder from the path
%
% This prevents this code from using the new BL object oriented PTB
% overrides.  We could include these inside of isetbio, but the risk is
% that whether this program worked or not would depend on whether isetbio
% was before or after PTB on the user's path, something we don't want to
% have to deal with.  Elsewhere (not in isetbio), we have established that
% the PTB and BrainardLab routines do the same thing (which is not
% surprising, as the actual calculations are done by the same underlying
% code in each case, just accessed differently.)
%[removedFolderFromCurrentPath, originalPath] = removeBrainardLabPTBOverrides();

% new script (is there an other one, here ?)

try
    %% Overview
    %
    % What we are going to do in this script is to create uniform field
    % corresponding to specified display and rgb values and pump it through
    % isetbio to get cone isomerization rates.  Then we are going to do the
    % calculation for the same display, cone fundamentals, and rgb values
    % in PTB.  We start with the isetbio calculation.
    
    %% Create isetbio display 
    displayToTest = 'LCD-Apple';
    d = displayCreate(displayToTest);
    gammaTable = displayGet(d, 'gamma table');
    if (size(gammaTable,2) ~=  3)
        error('Cannot deal with a display that has other than 3 primaries for this test.');
    end
    nInputLevels = size(gammaTable,1);
    
    %% Create a uniform field radiance image in ISETBIO
    % Use the display object and the passed RGB values.
    %
    % The assumption here is that isetbio uses the display depth to figure
    % out how to convert integers to the right input for gamma correction.
    %
    % ISETBIO displays work with integer display inputs, which makes the
    % bit depth explicit but which require that you keep track of the bit
    % depth carefully.
    % 
    % PTB works in a world where displays are driven with [0-1] real
    % numbers REPLACE_WITH_DASH_DASH this is how OpenGL works, with the display driver
    % responsible for digitizing. This keeps the code very portable but
    % does make it hard to know the bit depth.
    %
    % Choose RGB values in the range where the different gamma correction
    % methods used by ISETBIO and PTB agree (see v_DisplayLUTInversion).
    RGBToTest = [0.3 0.73 0.42]';
    %RGBToTest = [1 1 1]';
    theRGBImage = ones(20,20,3);
    for i1 = 1:3
        theRGBImage(:,:,i1) = round((nInputLevels-1)*RGBToTest(i1));
    end
    sceneDegrees = 10;  % need large field
    scene = sceneFromFile(theRGBImage,'rgb',[],d);
    scene = sceneSet(scene,'fov', sceneDegrees);
    sceneSize = sceneGet(scene,'size');
    if (runTimeParams.generatePlots)
        vcAddAndSelectObject(scene); sceneWindow;
    end
    
    %% Compute optial image, for delta function optics.
    oi = oiCreate('human');
    optics = oiGet(oi,'optics');
    optics = opticsSet(optics,'off axis method','skip');
    optics = opticsSet(optics,'otf method','skip otf');
    oi = oiSet(oi,'optics',optics);
    oi = oiCompute(scene,oi);
    oi = oiSet(oi,'fov',sceneDegrees);
    if (runTimeParams.generatePlots)
        vcAddAndSelectObject(oi); oiWindow;
    end
    
    %% Compute sensor image
    % 
    % Integration time is set to 1 second, so this comes out as
    % isomserizations per second.  The run without photon/shot noise, so
    % that the comparison will not be stochastic.
    sensorDegrees = 2;
    roiPixels = 10;
    sensor = sensorCreate('human');
    sensor = sensorSet(sensor,'wave',displayGet(d,'wave'));
    sensor = sensorSet(sensor, 'noise flag', 0);
    sensor = sensorSet(sensor,'exp time',1);
    sensor = sensorSet(sensor,'rows',128);
    sensor = sensorSet(sensor,'cols',128);
    [sensor, ~] = sensorSetSizeToFOV(sensor,sensorDegrees,scene,oi);
    sensor = sensorCompute(sensor,oi);
    if (runTimeParams.generatePlots)
        vcAddAndSelectObject(sensor); sensorWindow('scale',1);
    end
    
    %% Get the LMS isomerization rates out of the sensor image
    %
    % Pull out responses of each cone type within ROI. I am doing this by
    % brute force, because I can't find quite the right combination of ROI
    % gets from the sensor image.
    isetbioIsomerizationsArray = sensorGet(sensor,'photons');    
    sensorCFA = sensorGet(sensor,'cfa');
    sensorSizePixels = sensorGet(sensor,'size');
    rect = round([sensorSizePixels(2)/2,sensorSizePixels(1)/2,roiPixels,roiPixels]);
    sensorRoiLocs = ieRoi2Locs(rect);
    nLocs = size(sensorRoiLocs,1);
    sumIsomerizations = zeros(3,1);
    nSummed = zeros(3,1);    
    for jj = 1:nLocs
        % A type of 1 in the CFA is blank, so we subtract 1 from the number
        % in the CFA and skip any that end up as 0.  This is just one of
        % those things about ISETBIO that you have to know.  
        coneType = sensorCFA.pattern(sensorRoiLocs(jj,1),sensorRoiLocs(jj,2))-1;
        if (coneType > 0)
            sumIsomerizations(coneType) = sumIsomerizations(coneType)+isetbioIsomerizationsArray(sensorRoiLocs(jj,1),sensorRoiLocs(jj,2));
            nSummed(coneType) = nSummed(coneType) + 1;
        end
    end
    isetbioLMSIsomerizations = sumIsomerizations ./ nSummed;
    
    %% Get cone fundamentals that ISETBIO is using, for use with PTB routines.
    %
    % Get cone fundamentals out of isetbio sensor.  We keep these as
    % quantal efficiencies, because it is easier to think about how light
    % produces isomerizations if we work in quantal units.
    S_cones = WlsToS(sensorGet(sensor,'wave'));
    T_conesQE = sensorGet(sensor,'spectral qe')';
    T_conesQE = T_conesQE(2:4,:);
    
    %% Create PTB calibration structure from ISETBIO display object
    %
    % Specify parameters.  Screen dot pitch and pixel size have no effect
    % on this comparison, but we make something up just to remind us of how
    % to do this in the display to cal conversion should we ever be looking here
    % to figure it out.
    wave = displayGet(d, 'wave');
    isetbioPrimarySpdRadianceEnergy  = displayGet(d, 'spd primaries');
    dotsPerMeter = displayGet(d, 'dots per meter');
    screenSizeInPixels = [1920 1080];
    
    % Convert primaries from radiance to retinal irradiance
    % Adjust for difference in isetbio and PTB wavelength sampling
    % conventions, and take assume pupil size into account.
    %
    % I believe the area units here are meters^2, as that tends to
    % be the ISETBIO default.
    pupilDiameterMeters  = opticsGet(optics,'pupil diameter','m');
    pupilAreaMeters2 = pi*(pupilDiameterMeters/2)^2;
    eyeLengthMeters = opticsGet(optics,'focal length','m');
    ptbPrimarySpdIrradianceEnergy = RadianceAndPupilAreaEyeLengthToRetIrradiance(isetbioPrimarySpdRadianceEnergy,WlsToS(wave),pupilAreaMeters2,eyeLengthMeters);
    ptbPrimarySpdIrradianceEnergy = ptbPrimarySpdIrradianceEnergy*(wave(2)-wave(1));
    ptbPrimarySpdIrradiancePhotons = EnergyToQuanta(SToWls(wave),ptbPrimarySpdIrradianceEnergy);
      
    % Correct for differences in the way visual angle is computed in
    % ISETBIO versus PTB.  See v_IrradianceIsomerizations for (a little)
    % more on this point.
    m = opticsGet(optics,'magnification',sceneGet(scene,'distance'));
    ptbPrimarySpdMagCorrectIrradiancePhotons = ptbPrimarySpdIrradiancePhotons/(1+abs(m))^2;
    
    % Put into PTB cal structure
    PTBcal = ptb.GeneratePsychToolboxCalStruct(...
        'name', displayGet(d, 'name'), ...
        'gammaTable', gammaTable, ...
        'wave', wave, ...
        'spd', ptbPrimarySpdMagCorrectIrradiancePhotons, ...
        'screenSizeInPixels', screenSizeInPixels, ...
        'dotsPerMeter', dotsPerMeter ...
        );
    
    % Kluge.  Should set this properly in creation routine.  It might even
    % be possible to do so, I'm not sure and the documentation in the
    % function is not clear on what the options are (as there is no
    % documentation at all, sigh.)
    PTBcal.P_ambient = zeros(length(wave),1);
    
    %% Initialize PTB calibration structure.
    PTBcal = CalibrateFitGamma(PTBcal, nInputLevels);
    gammaMethod = 1;
    PTBcal = SetGammaMethod(PTBcal, gammaMethod, nInputLevels);
    PTBcal = SetSensorColorSpace(PTBcal,T_conesQE,S_cones);
    
    %% Compare PTB and ISETBIO LUT inversion
    %
    % These agree well, and match up with the plotted gamma table
    ptbRGBToTestPrimary = SettingsToPrimary(PTBcal,RGBToTest);
    isetbioRGBToTestPrimary = ieLUTDigital(theRGBImage(1,1,:),gammaTable);
    xVals = linspace(0,1,size(gammaTable,1))';
    if (runTimeParams.generatePlots)
        figure; hold on;
        plot(xVals,gammaTable(:,1),'r');
        plot(xVals,gammaTable(:,2),'g');
        plot(xVals,gammaTable(:,3),'b');
        plot([RGBToTest(1)],[ptbRGBToTestPrimary(1)],'ro','MarkerSize',4,'MarkerFaceColor','r');
        plot([RGBToTest(1)],[isetbioRGBToTestPrimary(1)],'rx','MarkerSize',6,'MarkerFaceColor','r');
        plot([RGBToTest(2)],[ptbRGBToTestPrimary(2)],'go','MarkerSize',4,'MarkerFaceColor','g');
        plot([RGBToTest(2)],[isetbioRGBToTestPrimary(2)],'gx','MarkerSize',6,'MarkerFaceColor','g');
        plot([RGBToTest(3)],[ptbRGBToTestPrimary(3)],'bo','MarkerSize',4,'MarkerFaceColor','b');
        plot([RGBToTest(3)],[isetbioRGBToTestPrimary(3)],'bx','MarkerSize',6,'MarkerFaceColor','b');
        xlabel('Input channel value (normalized 0-1)');
        ylabel('Output channel value (normalized 0-1)');
    end
    tolerance = 0.001;
    UnitTest.assertIsZero(abs(ptbRGBToTestPrimary(1)-isetbioRGBToTestPrimary(1)),'Red inversion comparison',tolerance);
    UnitTest.assertIsZero(abs(ptbRGBToTestPrimary(2)-isetbioRGBToTestPrimary(2)),'Green inversion comparison',tolerance);
    UnitTest.assertIsZero(abs(ptbRGBToTestPrimary(3)-isetbioRGBToTestPrimary(3)),'Blue inversion comparison',tolerance);
    
    %% Easy to check if PTB LUT inversion is invertible
    ptbRGBToTestCheck = PrimaryToSettings(PTBcal,ptbRGBToTestPrimary);
    tolerance = 0.001;
    UnitTest.assertIsZero(abs(ptbRGBToTestCheck(1)-RGBToTest(1)),'PTB red settings->primary->settings check',tolerance);
    UnitTest.assertIsZero(abs(ptbRGBToTestCheck(2)-RGBToTest(2)),'PTB green settings->primary->settings check',tolerance);
    UnitTest.assertIsZero(abs(ptbRGBToTestCheck(3)-RGBToTest(3)),'PTB blue settings->primary->settings check',tolerance);
    
    %% Compare irradiance in optical image with that computed directly from the primaries
    %
    % First grab irradiance out of the optical image. Then construct spd using the
    % primaries above and the PTB primary settings, obtained above using PTB lut
    % inversion.
    rect = [sceneSize(2)/2,sceneSize(1)/2,roiPixels,roiPixels];
    roiRoiLocs = ieRoi2Locs(rect);
    isetbioIrradianceSpdPhotons  = oiGet(oi,'roi mean photons',  roiRoiLocs); 
    ptbIrradianceSpdPhotons = ptbPrimarySpdMagCorrectIrradiancePhotons*ptbRGBToTestPrimary;
    if (runTimeParams.generatePlots)
        figure; clf; hold on;
        plot(wave,ptbIrradianceSpdPhotons./(wave(2)-wave(1)),'r');
        plot(wave,isetbioIrradianceSpdPhotons,'g');
        xlabel('Wavelength (nm)');
        ylabel('Irradiance (quanta/[sec-m2]');
    end
    
    %% PTB conversion to isomerization rates
    %
    % This gives isomerization rates for a cone with a collecting area of
    % one square meter.
    ptbLMSIsomerizationsRaw = SettingsToSensor(PTBcal,RGBToTest);
    
    % Adjust by cone size used in isetbio
    pixel = sensorGet(sensor,'pixel');
    sensorHeight = pixelGet(pixel,'height');
    sensorWidth = pixelGet(pixel,'width');
    sensorArea = sensorHeight*sensorWidth;
    ptbLMSIsomerizations = sensorArea*ptbLMSIsomerizationsRaw;
     
    %% Compare the two methods. 
    %
    % Agreement is better than 1% 
    isomerizationRatios = ptbLMSIsomerizations ./ isetbioLMSIsomerizations;
    fprintf('PTB/ISETBIO LMS isomerization ratios: %0.3f, %0.3f, %0.3f\n',isomerizationRatios(1),isomerizationRatios(2),isomerizationRatios(3));
    tolerance = 0.01;
    UnitTest.assertIsZero(abs(isomerizationRatios(1)-1),'L isomerization comparison',tolerance);
    UnitTest.assertIsZero(abs(isomerizationRatios(2)-1),'M isomerization comparison',tolerance);
    UnitTest.assertIsZero(abs(isomerizationRatios(3)-1),'S isomerization comparison',tolerance);
    
    % Log the data
    dataStruct = struct( ...
        'ptbIrradianceSpdPhotons',ptbIrradianceSpdPhotons, ...
        'isetbioIrradianceSpdPhotons',isetbioIrradianceSpdPhotons, ...
        'RGBToTest',RGBToTest, ...
        'ptbRGBToTestPrimary',ptbRGBToTestPrimary, ...
        'ptbRGBToTestCheck',ptbRGBToTestCheck, ...
        'isetbioRGBToTestPrimary',isetbioRGBToTestPrimary, ...
        'ptbLMSIsomerizations', ptbLMSIsomerizations, ...
        'isetbioLMSIsomerizations', isetbioLMSIsomerizations ...
        );
    
catch err
    % Restore original path and rethrow error
    if (~isempty(removedFolderFromCurrentPath))
        path(originalPath);
    end
    rethrow(err);
end

%% Restore original path
%if (~isempty(removedFolderFromCurrentPath))
%    path(originalPath);
%end

%% Save validation operations
UnitTest.validationData('conversionData', dataStruct);

%% Plot
if (runTimeParams.generatePlots)
    
end
end

% Helper method to remove the BrainardLabPTBOverrides folder if it exists on the current path.
% We want to remove this override, so we can use the original PTB functions
% without the CalStructOBJ (which is found only on our computers).
function [removedFolderFromCurrentPath, originalPath] = removeBrainardLabPTBOverrides

removedFolderFromCurrentPath = '';
originalPath = path;

% Folder to remove the Overrides/PTB-3 folder from the current path, if the folder exists on the path
PTBoverridesDirToRemoveFromPath = '/Users/Shared/Matlab/Toolboxes/BrainardLabToolbox/Overrides/PTB-3';

% determine if the PTBoverridesDirToRemoveFromPath is in the current path,
% and if it is remove it.
pathCell = regexp(path, pathsep, 'split');
for k = 1:numel(pathCell)
  % fprintf('[%d] = %s\n', k, pathCell{k});
   if (strncmpi(pathCell{k}, PTBoverridesDirToRemoveFromPath, numel(PTBoverridesDirToRemoveFromPath)))
       rmpath(pathCell{k});
       removedFolderFromCurrentPath{numel(removedFolderFromCurrentPath)+1} = pathCell{k};
       fprintf('Found ''%s'' path in entry %d. Removing it from the path.\n', pathCell{k},k);
   end
end

end


##### SOURCE END #####
--></body></html>