
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>v_wvfComputeConePSF</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-12-18"><meta name="DC.source" content="v_wvfComputeConePSF.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Function implementing the isetbio validation code</a></li><li><a href="#4">Initialize</a></li><li><a href="#5">Some informative text</a></li><li><a href="#6">Parameters</a></li><li><a href="#7">Test data</a></li><li><a href="#8">Initialize wvf structure</a></li><li><a href="#9">Include SCE if desired</a></li><li><a href="#10">Compute LMS psfs both for a subject and diffraction limited</a></li><li><a href="#11">Center and circularly average if desired</a></li><li><a href="#12">Make a figure comparable to Autrusseau et al, Figure 2 (top row) and Figure 4b (bottom row).</a></li><li><a href="#13">Make a plot through the peak of the returned LMS PSFs</a></li><li><a href="#14">Take a look in frequency domain.</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = v_wvfComputeConePSF(varargin)
<span class="comment">%</span>
<span class="comment">% Test the routines that compute L, M, and S cone PSFs from Zernike coefficients.</span>
<span class="comment">%</span>
<span class="comment">% Replicates figures from</span>
<span class="comment">%  Autrusseau et al., 2011, Vision Research, 51, 2282-2294.</span>
<span class="comment">%</span>
<span class="comment">% The diffraction limited calcs seem to match up with their</span>
<span class="comment">% Figure 2 pretty well, the MTFs agree well, and Figures 4A</span>
<span class="comment">% and B are reproduced to good approximation. There are</span>
<span class="comment">% small differenes in the max PSF between our calculation and</span>
<span class="comment">% their Figure 4A/B.  These may be due to differences in how</span>
<span class="comment">% the pupil/psf plane are sampled.  One of the S cone MTF</span>
<span class="comment">% points is also off, but not by more than might be attributable</span>
<span class="comment">% to digitization error of their Figure 11.</span>
<span class="comment">%</span>
<span class="comment">% This script actually checks many things, in that the agreement</span>
<span class="comment">% between what's calculated here and Figure 4A/B checks relies on</span>
<span class="comment">% many things being done in the same way.</span>
<span class="comment">%</span>
<span class="comment">% See also: wvfComputeConePSF, wvfComputePSF, wvfComputePupilFunction,</span>
<span class="comment">%   sceGetParams, wvfGetDefocusFromWavelengthDifference</span>
<span class="comment">%</span>
<span class="comment">% 8/21/11  dhb  Wrote it.</span>
<span class="comment">% 3/15/12  mdl  Edited to use wvfSet. Also updated to use fieldSampleSizeMMperPixel</span>
<span class="comment">% 7/20/12  dhb  Got TEST1 to work without crashing, and possibly even to be correct.</span>
<span class="comment">% 7/23/12  dhb  OTF plot is looking vaguely reasonable.</span>
<span class="comment">%               Added Autrusseau equal energy OTFs for comparison</span>
<span class="comment">% 8/18/15  dhb  UnitTestToolbox'ize.</span>

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
<span class="keyword">end</span>
</pre><h2>Function implementing the isetbio validation code<a name="2"></a></h2><pre class="codeinput"><span class="keyword">function</span> ValidationFunction(runTimeParams)
</pre><h2>Initialize<a name="4"></a></h2><pre class="codeinput">close <span class="string">all</span>; ieInit;
</pre><h2>Some informative text<a name="5"></a></h2><pre class="codeinput">UnitTest.validationRecord(<span class="string">'SIMPLE_MESSAGE'</span>, <span class="string">'Check L, M, S cone PSFs.'</span>);
</pre><h2>Parameters<a name="6"></a></h2><p>Autruesseau et al. did not incorporate a model of the SCE, nor did they center or circularly average the PSFs.  These switches let us play with those things if we want.</p><p>Note that the Autrusseau paper does not account for the SCE. This actually matters enough to be easily visible on the graphs.</p><pre class="codeinput">DOSCE = 0;
CIRCULARLYAVERAGE = 0;
CENTER = 0;
plotLimit = 6;
plotLimitFreq = 80;
</pre><h2>Test data<a name="7"></a></h2><pre class="codeinput">dataSource = <span class="string">'AutrusseauStandard'</span>;
<span class="keyword">switch</span> (dataSource)
    <span class="keyword">case</span> <span class="string">'AutrusseauStandard'</span>;
        <span class="comment">% This is the Autrusseau standard observer.</span>
        <span class="comment">%</span>
        <span class="comment">% Their coefficients are for a measured</span>
        <span class="comment">% pupil of 6 mm and that their calculations are</span>
        <span class="comment">% also for 6 mm. They use 570 nm as their</span>
        <span class="comment">% measured (in focus) wavelength.  [Their methods,</span>
        <span class="comment">% p. 2284].</span>
        <span class="comment">%</span>
        <span class="comment">% It appears that they do not zero the j = 4</span>
        <span class="comment">% coefficient at their in focus wavelength.</span>
        <span class="comment">% This is deduced by the fact that we get agreement</span>
        <span class="comment">% with their calculations without zeroing it out.</span>
        whichSubject = 1;
        dataFile = <span class="string">'autrusseauStandardObserver.txt'</span>;
        theZernikeCoeffs = importdata(dataFile);
        measPupilMM = 6;
        calcPupilMM = 6;
        measWavelength = 570;
    <span class="keyword">case</span> <span class="string">'ThibosStatisticalModelMean'</span>
        <span class="comment">% This is the mean data from the Thibos model</span>
        <span class="comment">% for a 6 mm pupil.  The methods of the Autrusseau</span>
        <span class="comment">% indicate that they only used the first 15 (starting</span>
        <span class="comment">% at j = 0 coefficients, so we lop them off at 15</span>
        <span class="comment">% (j = 14).</span>
        <span class="comment">%</span>
        <span class="comment">% Note that the comparison to Figure 11 of their</span>
        <span class="comment">% paper is not meaningful for this case.</span>
        whichSubject = 1;
        load(<span class="string">'IASstats60'</span>,<span class="string">'sample_mean'</span>);
        theZernikeCoeffs = sample_mean;
        theZernikeCoeffs = theZernikeCoeffs(1:15);
        measPupilMM = 6;
        calcPupilMM = 6;
        measWavelength = 570;
<span class="keyword">end</span>
UnitTest.validationData(<span class="string">'dataSource'</span>, dataSource);

<span class="comment">% Cone sensitivities and equal energy weighting spectrum</span>
load(<span class="string">'T_cones_ss2'</span>);
conePsfInfo.S = S_cones_ss2;
conePsfInfo.T = T_cones_ss2;
conePsfInfo.spdWeighting = ones(conePsfInfo.S(3),1);

<span class="comment">% Calculation wavelengths for PSF.</span>
wls = SToWls([400 10 31]);
</pre><h2>Initialize wvf structure<a name="8"></a></h2><pre class="codeinput">wvf0 = wvfCreate;

<span class="comment">% Set important parameters</span>
wvf0 = wvfSet(wvf0,<span class="string">'measured pupil size'</span>,measPupilMM);
wvf0 = wvfSet(wvf0,<span class="string">'calc pupil size'</span>,calcPupilMM);
wvf0 = wvfSet(wvf0,<span class="string">'zcoeffs'</span>,theZernikeCoeffs(:,whichSubject));
wvf0 = wvfSet(wvf0,<span class="string">'measured wavelength'</span>,measWavelength);
wvf0 = wvfSet(wvf0,<span class="string">'calc wavelengths'</span>,wls);
wvf0 = wvfSet(wvf0,<span class="string">'calc cone psf info'</span>,conePsfInfo);

<span class="comment">% The short wavelength PSFs get blurred enough that we need more pixels to</span>
<span class="comment">% contain them than our defaults provide.  Adjust this to keep sempling density</span>
<span class="comment">% in psf plane the same, but increase space sampled.  Autrusseau et al seem</span>
<span class="comment">% to have used 1 degree as the extent in the psf domain (based on Figure 4).</span>
<span class="comment">% You can see in their figure that this is not big enough -- the 400 nm psf</span>
<span class="comment">% for their standard observer (first panel in Figure 4b) wraps.</span>
<span class="comment">%</span>
<span class="comment">% With our default pupil plane parameters, 497 samples corresoponds closely to 1 degree</span>
<span class="comment">% sampling.  The code below prints out what you get.</span>
origSamples = wvfGet(wvf0,<span class="string">'number spatial samples'</span>);
newSamples = 497;
wvf0 = wvfSet(wvf0,<span class="string">'number spatial samples'</span>,newSamples);
fprintf(<span class="string">'Sampling pupil plane/psf with %d pixels\n'</span>,wvfGet(wvf0,<span class="string">'number spatial samples'</span>));
fprintf(<span class="string">'Pupil plane info\n'</span>);
<span class="keyword">for</span> wavelength = [400 500 600 700];
    fprintf(<span class="string">'\t%d nm, %0.1f mm, %0.3f mm/pixel\n'</span>,<span class="keyword">...</span>
        wavelength,wvfGet(wvf0,<span class="string">'pupil plane size'</span>,<span class="string">'mm'</span>,wavelength),wvfGet(wvf0,<span class="string">'pupil plane size'</span>,<span class="string">'mm'</span>,wavelength)/wvfGet(wvf0,<span class="string">'number spatial samples'</span>));
<span class="keyword">end</span>
fprintf(<span class="string">'PSF plane info\n'</span>);
<span class="keyword">for</span> wavelength = [400 500 600 700];
    fprintf(<span class="string">'\t%d nm, %0.1f minutes, %0.3f min/pixel\n'</span>,<span class="keyword">...</span>
        wavelength,wvfGet(wvf0,<span class="string">'psf angle per sample'</span>,<span class="string">'min'</span>,wavelength)*wvfGet(wvf0,<span class="string">'number spatial samples'</span>),wvfGet(wvf0,<span class="string">'psf angle per sample'</span>,<span class="string">'min'</span>,wavelength));
<span class="keyword">end</span>
</pre><pre class="codeoutput">Sampling pupil plane/psf with 497 pixels
Pupil plane info
	400 nm, 11.4 mm, 0.023 mm/pixel
	500 nm, 14.2 mm, 0.029 mm/pixel
	600 nm, 17.1 mm, 0.034 mm/pixel
	700 nm, 19.9 mm, 0.040 mm/pixel
PSF plane info
	400 nm, 60.1 minutes, 0.121 min/pixel
	500 nm, 60.1 minutes, 0.121 min/pixel
	600 nm, 60.1 minutes, 0.121 min/pixel
	700 nm, 60.1 minutes, 0.121 min/pixel
</pre><h2>Include SCE if desired<a name="9"></a></h2><pre class="codeinput"><span class="keyword">if</span> (DOSCE == 1)
    sce = sceCreate(wls,<span class="string">'berendschot_data'</span>,<span class="string">'centered'</span>);
    wvf0 = wvfSet(wvf0,<span class="string">'sce params'</span>,sce);
<span class="keyword">else</span>
    sce = sceCreate(wls,<span class="string">'none'</span>);
    wvf0 = wvfSet(wvf0,<span class="string">'sce params'</span>,sce);
<span class="keyword">end</span>
</pre><h2>Compute LMS psfs both for a subject and diffraction limited<a name="10"></a></h2><pre class="codeinput">wvfParams1 = wvf0;
wvfParams1 = wvfComputePSF(wvfParams1);
conePsf1 = wvfGet(wvfParams1,<span class="string">'cone psf'</span>);

wvfParams2 = wvf0;
wvfParams2 = wvfSet(wvfParams2,<span class="string">'zcoeffs'</span>,0);
wvfParams2 = wvfComputePSF(wvfParams2);
conePsf2 = wvfGet(wvfParams2,<span class="string">'cone psf'</span>);

<span class="comment">% This bit is a sanity check that our code yields constant sampling in the psf domain.</span>
<span class="comment">% Also compute arcminutes per pixel.</span>
whichRow = wvfGet(wvfParams1,<span class="string">'middle row'</span>);
<span class="keyword">for</span> i = 1:length(wls)
    <span class="keyword">if</span> (wvfGet(wvfParams1,<span class="string">'psf arcmin per sample'</span>,wls(1)) ~= wvfGet(wvfParams1,<span class="string">'psf arcmin per sample'</span>,wls(i)))
        error(<span class="string">'Error in spatial sampling consistency across wavelengths'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>
arcminutes1 = wvfGet(wvfParams1,<span class="string">'psf arcmin per sample'</span>,wls(1))*((1:wvfGet(wvfParams1,<span class="string">'spatial samples'</span>))-whichRow);
arcminutes = wvfGet(wvfParams1,<span class="string">'psf angular samples'</span>,<span class="string">'min'</span>,wls(1));
UnitTest.assertIsZero(max(abs(arcminutes(:)-arcminutes1(:))),<span class="string">'Angular samples compare'</span>,0);
</pre><h2>Center and circularly average if desired<a name="11"></a></h2><pre class="codeinput"><span class="keyword">if</span> (CENTER)
    lpsf = psfCenter(conePsf1(:,:,1));
    mpsf = psfCenter(conePsf1(:,:,2));
    spsf = psfCenter(conePsf1(:,:,3));
    lpsfd = psfCenter(conePsf2(:,:,1));
    mpsfd = psfCenter(conePsf2(:,:,2));
    spsfd = psfCenter(conePsf2(:,:,3));
<span class="keyword">else</span>
    lpsf = conePsf1(:,:,1);
    mpsf = conePsf1(:,:,2);
    spsf = conePsf1(:,:,3);
    lpsfd = conePsf2(:,:,1);
    mpsfd = conePsf2(:,:,2);
    spsfd = conePsf2(:,:,3);
<span class="keyword">end</span>
<span class="keyword">if</span> (CIRCULARLYAVERAGE)
    lpsf = psfCircularlyAverage(lpsf);
    mpsf = psfCircularlyAverage(mpsf);
    spsf = psfCircularlyAverage(spsf);
    lpsfd = psfCircularlyAverage(lpsfd);
    mpsfd = psfCircularlyAverage(mpsfd);
    spsfd = psfCircularlyAverage(spsfd);
<span class="keyword">end</span>
UnitTest.validationData(<span class="string">'lpsf'</span>, lpsf);
UnitTest.validationData(<span class="string">'mpsf'</span>, mpsf);
UnitTest.validationData(<span class="string">'spsf'</span>, spsf);
UnitTest.validationData(<span class="string">'lpsfd'</span>, lpsfd);
UnitTest.validationData(<span class="string">'mpsfd'</span>, mpsfd);
UnitTest.validationData(<span class="string">'spsfd'</span>, spsfd);
</pre><h2>Make a figure comparable to Autrusseau et al, Figure 2 (top row) and Figure 4b (bottom row).<a name="12"></a></h2><p>This shows diffraction limited and standard observer PSFs at different wavelengths, given focus at 570.  If the angular extent of the PSF is 1 degree, these should match up well with Figure 2 of Autresseau (diffraction limited) and Figure 4.  Look at 4a if the computation is for the Thibos mean and Figure 4b if the computation is for the Autrusseau standard observer.</p><p>Note that the 400 nm psf wraps at 400 nm in Figure 4b for the standard observer calculation.</p><p>The figure here also shows the pupil function phase, just for grins.</p><p>A useful figure to look at in comparing the figures generated here and in the paper is the maximum of the psf.  This is reported in the Autrusseau figures and also in ours.</p><pre class="codeinput"><span class="comment">% Diffraction limited (Figure 2)</span>
wavelengths = [400 550 700];
vcNewGraphWin([],<span class="string">'wide'</span>);
<span class="comment">% position = get(gcf,'Position');</span>
<span class="comment">% position(3) = 1600; position(4) = 800;</span>
<span class="comment">% set(gcf,'Position',position);</span>
<span class="keyword">for</span> i = 1:length(wavelengths);
    wavelength = wavelengths(i);

    subplot(2,length(wavelengths),i); hold <span class="string">on</span>
    [nil,p] = wvfPlot(wvfParams2,<span class="string">'image pupil phase'</span>,<span class="string">'mm'</span>,wavelength,<span class="string">'no window'</span>);

    focusWl = wvfGet(wvfParams2,<span class="string">'measured wavelength'</span>);
    subplot(2,length(wavelengths),i+length(wavelengths)); hold <span class="string">on</span>
    psf = wvfGet(wvfParams2,<span class="string">'psf'</span>,wavelength);
    maxVal = max(psf(:));
    <span class="comment">% [nil,p] = wvfPlot(wvfParams2,'2d psf angle','min',wavelength,'no window');</span>
    [nil,p] = wvfPlot(wvfParams2,<span class="string">'image psf angle'</span>,<span class="string">'min'</span>,wavelength,<span class="string">'no window'</span>);
    h = get(p,<span class="string">'Parent'</span>);
    view([0 90]); ylim([-30 30]); xlim([-30 30]); axis(<span class="string">'square'</span>);
    title(sprintf(<span class="string">'%d nm, focus %d nm, max = %0.5f'</span>,wavelength,focusWl,maxVal));
<span class="keyword">end</span>

<span class="comment">% With aberrations (Figure 4)</span>
vcNewGraphWin([],<span class="string">'wide'</span>);
<span class="comment">% position = get(gcf,'Position');</span>
<span class="comment">% position(3) = 1600; position(4) = 800;</span>
<span class="comment">% set(gcf,'Position',position);</span>
<span class="keyword">for</span> i = 1:length(wavelengths);
    wavelength = wavelengths(i);

    subplot(2,length(wavelengths),i); hold <span class="string">on</span>
    [nil,p] = wvfPlot(wvfParams1,<span class="string">'image pupil phase'</span>,<span class="string">'mm'</span>,wavelength,<span class="string">'no window'</span>);
    <span class="comment">%h = get(p,'Parent');</span>
    <span class="comment">%view([0 90]); ylim([-30 30]); xlim([-30 30]); axis('square');</span>
    <span class="comment">%title(sprintf('%d nm, focus %d nm, max = %0.5f',wavelength,focusWl,maxVal));</span>

    subplot(2,length(wavelengths),i+length(wavelengths)); hold <span class="string">on</span>
    psf = wvfGet(wvfParams1,<span class="string">'psf'</span>,wavelength);
    maxVal = max(psf(:));
    <span class="comment">%[nil,p] = wvfPlot(wvfParams1,'2d psf angle','min',wavelength,'no window');</span>
    [nil,p] = wvfPlot(wvfParams1,<span class="string">'image psf angle'</span>,<span class="string">'min'</span>,wavelength,<span class="string">'no window'</span>);
    h = get(p,<span class="string">'Parent'</span>);
    view([0 90]); ylim([-30 30]); xlim([-30 30]); axis(<span class="string">'square'</span>);
    title(sprintf(<span class="string">'%d nm, focus %d nm, max = %0.5f'</span>,wavelength,focusWl,maxVal));
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="v_wvfComputeConePSF_01.png" style="width:1792px;height:432px;" alt=""> <img vspace="5" hspace="5" src="v_wvfComputeConePSF_02.png" style="width:1792px;height:432px;" alt=""> <h2>Make a plot through the peak of the returned LMS PSFs<a name="13"></a></h2><p>Compare with diffraction limited + defocus</p><pre class="codeinput"><span class="comment">% The position setting was a bit specific to some monitor.  I tried to make</span>
<span class="comment">% vcNewGraphWin do the right thing.</span>
vcNewGraphWin([],<span class="string">'wide'</span>);
<span class="comment">% position = get(gcf,'Position');</span>
<span class="comment">% position(3) = 1600;</span>
<span class="comment">% set(gcf,'Position',position);</span>
subplot(1,3,1); hold <span class="string">on</span>
onedLPSF = lpsf(whichRow,:);
onedLPSFD = lpsfd(whichRow,:);
index = find(abs(arcminutes) &lt; plotLimit);
plot(arcminutes(index),onedLPSF(index),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2);
plot(arcminutes(index),onedLPSFD(index),<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,4);
xlabel(<span class="string">'Arc Minutes'</span>);
ylabel(<span class="string">'PSF'</span>);
<span class="keyword">if</span> (CIRCULARLYAVERAGE)
    title(<span class="string">'Circularized L cone PSF'</span>);
<span class="keyword">else</span>
    title(<span class="string">'L cone PSF'</span>);
<span class="keyword">end</span>

subplot(1,3,2); hold <span class="string">on</span>
onedMPSF = mpsf(whichRow,:);
onedMPSFD = mpsfd(whichRow,:);
index = find(abs(arcminutes) &lt; plotLimit);
plot(arcminutes(index),onedMPSF(index),<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,2);
plot(arcminutes(index),onedMPSFD(index),<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,4);
xlabel(<span class="string">'Arc Minutes'</span>);
ylabel(<span class="string">'PSF'</span>);
<span class="keyword">if</span> (CIRCULARLYAVERAGE)
    title(<span class="string">'Circularized M cone PSF'</span>);
<span class="keyword">else</span>
    title(<span class="string">'M cone PSF'</span>);
<span class="keyword">end</span>

subplot(1,3,3); hold <span class="string">on</span>
onedSPSF = spsf(whichRow,:);
onedSPSFD = spsfd(whichRow,:);
index = find(abs(arcminutes) &lt; plotLimit);
plot(arcminutes(index),onedSPSF(index),<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,2);
plot(arcminutes(index),onedSPSFD(index),<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,4);
xlabel(<span class="string">'Arc Minutes'</span>);
ylabel(<span class="string">'PSF'</span>);
<span class="keyword">if</span> (CIRCULARLYAVERAGE)
    title(<span class="string">'Circularized S cone PSF'</span>);
<span class="keyword">else</span>
    title(<span class="string">'S cone PSF'</span>);
<span class="keyword">end</span>
drawnow;
</pre><img vspace="5" hspace="5" src="v_wvfComputeConePSF_03.png" style="width:1792px;height:432px;" alt=""> <h2>Take a look in frequency domain.<a name="14"></a></h2><p>Perhaps we should be using psf2otf, but it  centers its output in a counterintuitive way and the fft seems like it should work just fine.</p><p>Autrusseau et al. appear to find the OTF by explicitly convolving the PSF with vertical gratings of different spatial frequencies, but that seems inefficient relative to believing the fft.</p><pre class="codeinput">lotf = fftshift(fft2(lpsf));
motf = fftshift(fft2(mpsf));
sotf = fftshift(fft2(spsf));
lotfd = fftshift(fft2(lpsfd));
motfd = fftshift(fft2(mpsfd));
sotfd = fftshift(fft2(spsfd));

<span class="comment">% Figure out the scale in the frequency domain.</span>
<span class="comment">%</span>
<span class="comment">% Logic is that one pixel in the frequency domain</span>
<span class="comment">% is one cycle per image.  So find size of image</span>
<span class="comment">% in degrees and use this to find the numbers</span>
<span class="comment">% of cycles per degree corresponding to each pixel.</span>
<span class="comment">% Then produce a variable that corresponds to</span>
<span class="comment">% cycles per degree.</span>
totalDegrees = (arcminutes(end)-arcminutes(1))/60;
cyclesDegreePerPixel = 1/totalDegrees;
cyclesdegree = cyclesDegreePerPixel*((1:wvfGet(wvfParams1,<span class="string">'number spatial samples'</span>))-whichRow);

<span class="comment">% Read in Autrusseau MTF data for comparison</span>
<span class="comment">%</span>
<span class="comment">% Autrussea et al. didn't use the Fourier transform</span>
<span class="comment">% instead literally convolved the psf at each wavelength</span>
<span class="comment">% with a sinusoidal stimulus at the same wavelength, and then summed</span>
<span class="comment">% up the results over wavelength, weighting by the cone sensitivities.</span>
autrusseauFigure11 = ReadStructsFromText(<span class="string">'autrusseauFigure11.txt'</span>);

<span class="comment">% Make a plot of the vertical grating LMS MTFs (solid colored line, taken as</span>
<span class="comment">% middle row of full MTFs) that we get, and compare to what Autrusseau et al. got.</span>
<span class="comment">% Dashed colord line is horizontal grating MTFs.  Black lines are MTFs for</span>
<span class="comment">% diffraction plus defocus</span>
theFig = vcNewGraphWin([],<span class="string">'wide'</span>); clf;
subplot(1,3,1); hold <span class="string">on</span>
onedLOTFH = abs(lotf(whichRow,:));
onedLOTFV = abs(lotf(:,whichRow));
onedLOTFD = abs(lotfd(whichRow,:));
index = find(abs(cyclesdegree) &lt; plotLimitFreq);
plot(cyclesdegree(index),log10(onedLOTFH(index)),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2);
plot(cyclesdegree(index),log10(onedLOTFV(index)),<span class="string">'r:'</span>,<span class="string">'LineWidth'</span>,2);
plot([autrusseauFigure11.sf_cpd],log10([autrusseauFigure11.Lmtf_ees]),<span class="string">'ro'</span>,<span class="string">'MarkerSize'</span>,8,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>);
plot(cyclesdegree(index),log10(onedLOTFD(index)),<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,1);
xlim([0 plotLimitFreq]);
ylim([-3 0]);
xlabel(<span class="string">'Cycles/Degree'</span>);
ylabel(<span class="string">'LOG10 OTF'</span>);
<span class="keyword">if</span> (CIRCULARLYAVERAGE)
    title(<span class="string">'Circularized L cone PSF'</span>);
<span class="keyword">else</span>
    title(<span class="string">'L cone OTF'</span>);
<span class="keyword">end</span>

subplot(1,3,2); hold <span class="string">on</span>
onedMOTFH = abs(motf(whichRow,:));
onedMOTFV = abs(motf(:,whichRow));
onedMOTFD = abs(motfd(whichRow,:));
index = find(abs(cyclesdegree) &lt; plotLimitFreq);
plot(cyclesdegree(index),log10(onedMOTFH(index)),<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,2);
plot(cyclesdegree(index),log10(onedMOTFV(index)),<span class="string">'g:'</span>,<span class="string">'LineWidth'</span>,2);
plot([autrusseauFigure11.sf_cpd],log10([autrusseauFigure11.Mmtf_ees]),<span class="string">'go'</span>,<span class="string">'MarkerSize'</span>,8,<span class="string">'MarkerFaceColor'</span>,<span class="string">'g'</span>);
plot(cyclesdegree(index),log10(onedMOTFD(index)),<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,1);
xlim([0 plotLimitFreq]);
ylim([-3 0]);
xlabel(<span class="string">'Cycles/Degree'</span>);
ylabel(<span class="string">'LOG10 OTF'</span>);
<span class="keyword">if</span> (CIRCULARLYAVERAGE)
    title(<span class="string">'Circularized M cone PSF'</span>);
<span class="keyword">else</span>
    title(<span class="string">'M cone OTF'</span>);
<span class="keyword">end</span>

subplot(1,3,3); hold <span class="string">on</span>
onedSOTFH = abs(sotf(whichRow,:));
onedSOTFV = abs(sotf(:,whichRow));
onedSOTFD = abs(sotfd(whichRow,:));
index = find(abs(cyclesdegree) &lt; plotLimitFreq);
plot(cyclesdegree(index),log10(onedSOTFH(index)),<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,2);
plot(cyclesdegree(index),log10(onedSOTFV(index)),<span class="string">'b:'</span>,<span class="string">'LineWidth'</span>,2);
plot([autrusseauFigure11.sf_cpd],log10([autrusseauFigure11.Smtf_ees]),<span class="string">'bo'</span>,<span class="string">'MarkerSize'</span>,8,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>);
plot(cyclesdegree(index),log10(onedSOTFD(index)),<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,1);
xlim([0 plotLimitFreq]);
ylim([-3 0]);
xlabel(<span class="string">'Cycles/Degree'</span>);
ylabel(<span class="string">'LOG10 OTF'</span>);
<span class="keyword">if</span> (CIRCULARLYAVERAGE)
    title(<span class="string">'Circularized S cone PSF'</span>);
<span class="keyword">else</span>
    title(<span class="string">'S cone OTF'</span>);
<span class="keyword">end</span>
drawnow;
</pre><img vspace="5" hspace="5" src="v_wvfComputeConePSF_04.png" style="width:1792px;height:432px;" alt=""> <pre class="codeinput"><span class="keyword">end</span>

<span class="comment">% Need to come back to this code and get it working.</span>
<span class="comment">%</span>
<span class="comment">% %% TEST2.  Optimize focus and add to the plot.</span>
<span class="comment">% %</span>
<span class="comment">% % This takes a long time.</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% %Should be using sets/gets</span>
<span class="comment">%</span>
<span class="comment">% wvfParams3 = wvf0;</span>
<span class="comment">% wvfParams3.coneWeights = [1 1 0];</span>
<span class="comment">% wvfParams3.criterionFraction = 0.9;</span>
<span class="comment">%</span>
<span class="comment">% % This takes a long time and produces an error that could be fixed by BW,</span>
<span class="comment">% % but he is too lazy.</span>
<span class="comment">% %  Error using wvfGet (line 590)</span>
<span class="comment">% %   Must explicitly compute PSF on wvf structure before getting it.  Use wvfComputePSF</span>
<span class="comment">%</span>
<span class="comment">% wvfParams3 = wvfComputeOptimizedConePSF(wvfParams3);</span>
<span class="comment">%</span>
<span class="comment">% lpsfo = psfCenter(wvfParams3.conepsf(:,:,1));</span>
<span class="comment">% mpsfo = psfCenter(wvfParams3.conepsf(:,:,2));</span>
<span class="comment">% spsfo = psfCenter(wvfParams3.conepsf(:,:,3));</span>
<span class="comment">% if (CIRCULARLYAVERAGE)</span>
<span class="comment">%     lpsfo = psfCircularlyAverage(lpsfo);</span>
<span class="comment">%     mpsfo = psfCircularlyAverage(mpsfo);</span>
<span class="comment">%     spsfo = psfCircularlyAverage(spsfo);</span>
<span class="comment">% end</span>
<span class="comment">% onedLPSFo = lpsfo(whichRow,:);</span>
<span class="comment">% onedMPSFo = mpsfo(whichRow,:);</span>
<span class="comment">% onedSPSFo = spsfo(whichRow,:);</span>
<span class="comment">%</span>
<span class="comment">% figure(theFig);</span>
<span class="comment">% subplot(1,3,1);</span>
<span class="comment">% plot(arcminutes(index),onedLPSFo(index),'r','LineWidth',4);</span>
<span class="comment">% subplot(1,3,2); hold on</span>
<span class="comment">% plot(arcminutes(index),onedMPSFo(index),'g','LineWidth',4);</span>
<span class="comment">% subplot(1,3,3); hold on</span>
<span class="comment">% plot(arcminutes(index),onedSPSFo(index),'b','LineWidth',4);</span>
<span class="comment">% drawnow;</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = v_wvfComputeConePSF(varargin)
%
% Test the routines that compute L, M, and S cone PSFs from Zernike coefficients.
%
% Replicates figures from 
%  Autrusseau et al., 2011, Vision Research, 51, 2282-2294.
%
% The diffraction limited calcs seem to match up with their
% Figure 2 pretty well, the MTFs agree well, and Figures 4A
% and B are reproduced to good approximation. There are
% small differenes in the max PSF between our calculation and
% their Figure 4A/B.  These may be due to differences in how
% the pupil/psf plane are sampled.  One of the S cone MTF
% points is also off, but not by more than might be attributable
% to digitization error of their Figure 11.
%
% This script actually checks many things, in that the agreement
% between what's calculated here and Figure 4A/B checks relies on
% many things being done in the same way.
%
% See also: wvfComputeConePSF, wvfComputePSF, wvfComputePupilFunction,
%   sceGetParams, wvfGetDefocusFromWavelengthDifference
%
% 8/21/11  dhb  Wrote it.
% 3/15/12  mdl  Edited to use wvfSet. Also updated to use fieldSampleSizeMMperPixel
% 7/20/12  dhb  Got TEST1 to work without crashing, and possibly even to be correct.
% 7/23/12  dhb  OTF plot is looking vaguely reasonable.
%               Added Autrusseau equal energy OTFs for comparison
% 8/18/15  dhb  UnitTestToolbox'ize.

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
end

%% Function implementing the isetbio validation code
function ValidationFunction(runTimeParams)

%% Initialize
close all; ieInit;
%% Some informative text
UnitTest.validationRecord('SIMPLE_MESSAGE', 'Check L, M, S cone PSFs.');

%% Parameters
%
% Autruesseau et al. did not incorporate a model of the SCE,
% nor did they center or circularly average the PSFs.  These
% switches let us play with those things if we want.
%
% Note that the Autrusseau paper does not account for the SCE.
% This actually matters enough to be easily visible on the graphs.
DOSCE = 0;
CIRCULARLYAVERAGE = 0;
CENTER = 0;
plotLimit = 6;
plotLimitFreq = 80;

%% Test data
dataSource = 'AutrusseauStandard';
switch (dataSource)
    case 'AutrusseauStandard';
        % This is the Autrusseau standard observer.
        %
        % Their coefficients are for a measured
        % pupil of 6 mm and that their calculations are
        % also for 6 mm. They use 570 nm as their
        % measured (in focus) wavelength.  [Their methods,
        % p. 2284].
        %
        % It appears that they do not zero the j = 4
        % coefficient at their in focus wavelength.
        % This is deduced by the fact that we get agreement
        % with their calculations without zeroing it out.
        whichSubject = 1;
        dataFile = 'autrusseauStandardObserver.txt';
        theZernikeCoeffs = importdata(dataFile);
        measPupilMM = 6;
        calcPupilMM = 6;
        measWavelength = 570;
    case 'ThibosStatisticalModelMean'
        % This is the mean data from the Thibos model
        % for a 6 mm pupil.  The methods of the Autrusseau
        % indicate that they only used the first 15 (starting
        % at j = 0 coefficients, so we lop them off at 15
        % (j = 14).
        %
        % Note that the comparison to Figure 11 of their
        % paper is not meaningful for this case.
        whichSubject = 1;
        load('IASstats60','sample_mean');
        theZernikeCoeffs = sample_mean;
        theZernikeCoeffs = theZernikeCoeffs(1:15);
        measPupilMM = 6;
        calcPupilMM = 6;
        measWavelength = 570;
end
UnitTest.validationData('dataSource', dataSource);

% Cone sensitivities and equal energy weighting spectrum
load('T_cones_ss2');
conePsfInfo.S = S_cones_ss2;
conePsfInfo.T = T_cones_ss2;
conePsfInfo.spdWeighting = ones(conePsfInfo.S(3),1);

% Calculation wavelengths for PSF.  
wls = SToWls([400 10 31]);

%% Initialize wvf structure
wvf0 = wvfCreate;

% Set important parameters
wvf0 = wvfSet(wvf0,'measured pupil size',measPupilMM);
wvf0 = wvfSet(wvf0,'calc pupil size',calcPupilMM);
wvf0 = wvfSet(wvf0,'zcoeffs',theZernikeCoeffs(:,whichSubject));
wvf0 = wvfSet(wvf0,'measured wavelength',measWavelength);
wvf0 = wvfSet(wvf0,'calc wavelengths',wls);
wvf0 = wvfSet(wvf0,'calc cone psf info',conePsfInfo);

% The short wavelength PSFs get blurred enough that we need more pixels to
% contain them than our defaults provide.  Adjust this to keep sempling density
% in psf plane the same, but increase space sampled.  Autrusseau et al seem
% to have used 1 degree as the extent in the psf domain (based on Figure 4).
% You can see in their figure that this is not big enough REPLACE_WITH_DASH_DASH the 400 nm psf
% for their standard observer (first panel in Figure 4b) wraps.
%
% With our default pupil plane parameters, 497 samples corresoponds closely to 1 degree
% sampling.  The code below prints out what you get.
origSamples = wvfGet(wvf0,'number spatial samples');
newSamples = 497;
wvf0 = wvfSet(wvf0,'number spatial samples',newSamples);
fprintf('Sampling pupil plane/psf with %d pixels\n',wvfGet(wvf0,'number spatial samples'));
fprintf('Pupil plane info\n');
for wavelength = [400 500 600 700];
    fprintf('\t%d nm, %0.1f mm, %0.3f mm/pixel\n',...
        wavelength,wvfGet(wvf0,'pupil plane size','mm',wavelength),wvfGet(wvf0,'pupil plane size','mm',wavelength)/wvfGet(wvf0,'number spatial samples'));
end
fprintf('PSF plane info\n');
for wavelength = [400 500 600 700];
    fprintf('\t%d nm, %0.1f minutes, %0.3f min/pixel\n',...
        wavelength,wvfGet(wvf0,'psf angle per sample','min',wavelength)*wvfGet(wvf0,'number spatial samples'),wvfGet(wvf0,'psf angle per sample','min',wavelength));
end

%% Include SCE if desired
if (DOSCE == 1)
    sce = sceCreate(wls,'berendschot_data','centered');
    wvf0 = wvfSet(wvf0,'sce params',sce);
else
    sce = sceCreate(wls,'none');
    wvf0 = wvfSet(wvf0,'sce params',sce);
end

%% Compute LMS psfs both for a subject and diffraction limited
wvfParams1 = wvf0;
wvfParams1 = wvfComputePSF(wvfParams1);
conePsf1 = wvfGet(wvfParams1,'cone psf');

wvfParams2 = wvf0;
wvfParams2 = wvfSet(wvfParams2,'zcoeffs',0);
wvfParams2 = wvfComputePSF(wvfParams2);
conePsf2 = wvfGet(wvfParams2,'cone psf');

% This bit is a sanity check that our code yields constant sampling in the psf domain.
% Also compute arcminutes per pixel.
whichRow = wvfGet(wvfParams1,'middle row');
for i = 1:length(wls)
    if (wvfGet(wvfParams1,'psf arcmin per sample',wls(1)) ~= wvfGet(wvfParams1,'psf arcmin per sample',wls(i)))
        error('Error in spatial sampling consistency across wavelengths');
    end
end
arcminutes1 = wvfGet(wvfParams1,'psf arcmin per sample',wls(1))*((1:wvfGet(wvfParams1,'spatial samples'))-whichRow);
arcminutes = wvfGet(wvfParams1,'psf angular samples','min',wls(1));
UnitTest.assertIsZero(max(abs(arcminutes(:)-arcminutes1(:))),'Angular samples compare',0);

%% Center and circularly average if desired
if (CENTER)
    lpsf = psfCenter(conePsf1(:,:,1));
    mpsf = psfCenter(conePsf1(:,:,2));
    spsf = psfCenter(conePsf1(:,:,3));
    lpsfd = psfCenter(conePsf2(:,:,1));
    mpsfd = psfCenter(conePsf2(:,:,2));
    spsfd = psfCenter(conePsf2(:,:,3));
else
    lpsf = conePsf1(:,:,1);
    mpsf = conePsf1(:,:,2);
    spsf = conePsf1(:,:,3);
    lpsfd = conePsf2(:,:,1);
    mpsfd = conePsf2(:,:,2);
    spsfd = conePsf2(:,:,3);
end
if (CIRCULARLYAVERAGE)
    lpsf = psfCircularlyAverage(lpsf);
    mpsf = psfCircularlyAverage(mpsf);
    spsf = psfCircularlyAverage(spsf);
    lpsfd = psfCircularlyAverage(lpsfd);
    mpsfd = psfCircularlyAverage(mpsfd);
    spsfd = psfCircularlyAverage(spsfd);
end
UnitTest.validationData('lpsf', lpsf);
UnitTest.validationData('mpsf', mpsf);
UnitTest.validationData('spsf', spsf);
UnitTest.validationData('lpsfd', lpsfd);
UnitTest.validationData('mpsfd', mpsfd);
UnitTest.validationData('spsfd', spsfd);

%% Make a figure comparable to Autrusseau et al, Figure 2 (top row) and Figure 4b (bottom row).
%
% This shows diffraction limited and standard observer PSFs at different
% wavelengths, given focus at 570.  If the angular extent of the PSF is 1 degree,
% these should match up well with Figure 2 of Autresseau (diffraction limited)
% and Figure 4.  Look at 4a if the computation is for the Thibos mean and Figure 4b 
% if the computation is for the Autrusseau standard observer.
%
% Note that the 400 nm psf wraps at 400 nm in Figure 4b for the standard observer calculation.
%
% The figure here also shows the pupil function phase, just for grins.
%
% A useful figure to look at in comparing the figures generated here and in the paper
% is the maximum of the psf.  This is reported in the Autrusseau figures and also 
% in ours.

% Diffraction limited (Figure 2)
wavelengths = [400 550 700];
vcNewGraphWin([],'wide');
% position = get(gcf,'Position');
% position(3) = 1600; position(4) = 800;
% set(gcf,'Position',position);
for i = 1:length(wavelengths);
    wavelength = wavelengths(i);
    
    subplot(2,length(wavelengths),i); hold on
    [nil,p] = wvfPlot(wvfParams2,'image pupil phase','mm',wavelength,'no window');
    
    focusWl = wvfGet(wvfParams2,'measured wavelength');
    subplot(2,length(wavelengths),i+length(wavelengths)); hold on
    psf = wvfGet(wvfParams2,'psf',wavelength);
    maxVal = max(psf(:));
    % [nil,p] = wvfPlot(wvfParams2,'2d psf angle','min',wavelength,'no window');
    [nil,p] = wvfPlot(wvfParams2,'image psf angle','min',wavelength,'no window');
    h = get(p,'Parent');
    view([0 90]); ylim([-30 30]); xlim([-30 30]); axis('square');
    title(sprintf('%d nm, focus %d nm, max = %0.5f',wavelength,focusWl,maxVal));
end

% With aberrations (Figure 4)
vcNewGraphWin([],'wide');
% position = get(gcf,'Position');
% position(3) = 1600; position(4) = 800;
% set(gcf,'Position',position);
for i = 1:length(wavelengths);
    wavelength = wavelengths(i);
    
    subplot(2,length(wavelengths),i); hold on
    [nil,p] = wvfPlot(wvfParams1,'image pupil phase','mm',wavelength,'no window');
    %h = get(p,'Parent');
    %view([0 90]); ylim([-30 30]); xlim([-30 30]); axis('square');
    %title(sprintf('%d nm, focus %d nm, max = %0.5f',wavelength,focusWl,maxVal));

    subplot(2,length(wavelengths),i+length(wavelengths)); hold on
    psf = wvfGet(wvfParams1,'psf',wavelength);
    maxVal = max(psf(:));
    %[nil,p] = wvfPlot(wvfParams1,'2d psf angle','min',wavelength,'no window');
    [nil,p] = wvfPlot(wvfParams1,'image psf angle','min',wavelength,'no window');
    h = get(p,'Parent');
    view([0 90]); ylim([-30 30]); xlim([-30 30]); axis('square');
    title(sprintf('%d nm, focus %d nm, max = %0.5f',wavelength,focusWl,maxVal));
end

%% Make a plot through the peak of the returned LMS PSFs 
% Compare with diffraction limited + defocus

% The position setting was a bit specific to some monitor.  I tried to make
% vcNewGraphWin do the right thing.
vcNewGraphWin([],'wide'); 
% position = get(gcf,'Position');
% position(3) = 1600;
% set(gcf,'Position',position);
subplot(1,3,1); hold on
onedLPSF = lpsf(whichRow,:);
onedLPSFD = lpsfd(whichRow,:);
index = find(abs(arcminutes) < plotLimit);
plot(arcminutes(index),onedLPSF(index),'r','LineWidth',2);
plot(arcminutes(index),onedLPSFD(index),'k','LineWidth',4);
xlabel('Arc Minutes');
ylabel('PSF');
if (CIRCULARLYAVERAGE)
    title('Circularized L cone PSF');
else
    title('L cone PSF');
end

subplot(1,3,2); hold on
onedMPSF = mpsf(whichRow,:);
onedMPSFD = mpsfd(whichRow,:);
index = find(abs(arcminutes) < plotLimit);
plot(arcminutes(index),onedMPSF(index),'g','LineWidth',2);
plot(arcminutes(index),onedMPSFD(index),'k','LineWidth',4);
xlabel('Arc Minutes');
ylabel('PSF');
if (CIRCULARLYAVERAGE)
    title('Circularized M cone PSF');
else
    title('M cone PSF');
end

subplot(1,3,3); hold on
onedSPSF = spsf(whichRow,:);
onedSPSFD = spsfd(whichRow,:);
index = find(abs(arcminutes) < plotLimit);
plot(arcminutes(index),onedSPSF(index),'b','LineWidth',2);
plot(arcminutes(index),onedSPSFD(index),'k','LineWidth',4);
xlabel('Arc Minutes');
ylabel('PSF');
if (CIRCULARLYAVERAGE)
    title('Circularized S cone PSF');
else
    title('S cone PSF');
end
drawnow;

%% Take a look in frequency domain.
%
% Perhaps we should be using psf2otf, but it  centers its output in
% a counterintuitive way and the fft seems like it should work just
% fine.
%
% Autrusseau et al. appear to find the OTF by explicitly convolving
% the PSF with vertical gratings of different spatial frequencies,
% but that seems inefficient relative to believing the fft.
lotf = fftshift(fft2(lpsf));
motf = fftshift(fft2(mpsf));
sotf = fftshift(fft2(spsf));
lotfd = fftshift(fft2(lpsfd));
motfd = fftshift(fft2(mpsfd));
sotfd = fftshift(fft2(spsfd));

% Figure out the scale in the frequency domain.
% 
% Logic is that one pixel in the frequency domain
% is one cycle per image.  So find size of image
% in degrees and use this to find the numbers
% of cycles per degree corresponding to each pixel.
% Then produce a variable that corresponds to 
% cycles per degree.
totalDegrees = (arcminutes(end)-arcminutes(1))/60;
cyclesDegreePerPixel = 1/totalDegrees;
cyclesdegree = cyclesDegreePerPixel*((1:wvfGet(wvfParams1,'number spatial samples'))-whichRow);

% Read in Autrusseau MTF data for comparison
%
% Autrussea et al. didn't use the Fourier transform
% instead literally convolved the psf at each wavelength
% with a sinusoidal stimulus at the same wavelength, and then summed
% up the results over wavelength, weighting by the cone sensitivities.
autrusseauFigure11 = ReadStructsFromText('autrusseauFigure11.txt');

% Make a plot of the vertical grating LMS MTFs (solid colored line, taken as
% middle row of full MTFs) that we get, and compare to what Autrusseau et al. got.
% Dashed colord line is horizontal grating MTFs.  Black lines are MTFs for 
% diffraction plus defocus 
theFig = vcNewGraphWin([],'wide'); clf;
subplot(1,3,1); hold on
onedLOTFH = abs(lotf(whichRow,:));
onedLOTFV = abs(lotf(:,whichRow));
onedLOTFD = abs(lotfd(whichRow,:));
index = find(abs(cyclesdegree) < plotLimitFreq);
plot(cyclesdegree(index),log10(onedLOTFH(index)),'r','LineWidth',2);
plot(cyclesdegree(index),log10(onedLOTFV(index)),'r:','LineWidth',2);
plot([autrusseauFigure11.sf_cpd],log10([autrusseauFigure11.Lmtf_ees]),'ro','MarkerSize',8,'MarkerFaceColor','r');
plot(cyclesdegree(index),log10(onedLOTFD(index)),'k','LineWidth',1);
xlim([0 plotLimitFreq]);
ylim([-3 0]);
xlabel('Cycles/Degree');
ylabel('LOG10 OTF');
if (CIRCULARLYAVERAGE)
    title('Circularized L cone PSF');
else
    title('L cone OTF');
end

subplot(1,3,2); hold on
onedMOTFH = abs(motf(whichRow,:));
onedMOTFV = abs(motf(:,whichRow));
onedMOTFD = abs(motfd(whichRow,:));
index = find(abs(cyclesdegree) < plotLimitFreq);
plot(cyclesdegree(index),log10(onedMOTFH(index)),'g','LineWidth',2);
plot(cyclesdegree(index),log10(onedMOTFV(index)),'g:','LineWidth',2);
plot([autrusseauFigure11.sf_cpd],log10([autrusseauFigure11.Mmtf_ees]),'go','MarkerSize',8,'MarkerFaceColor','g');
plot(cyclesdegree(index),log10(onedMOTFD(index)),'k','LineWidth',1);
xlim([0 plotLimitFreq]);
ylim([-3 0]);
xlabel('Cycles/Degree');
ylabel('LOG10 OTF');
if (CIRCULARLYAVERAGE)
    title('Circularized M cone PSF');
else
    title('M cone OTF');
end

subplot(1,3,3); hold on
onedSOTFH = abs(sotf(whichRow,:));
onedSOTFV = abs(sotf(:,whichRow));
onedSOTFD = abs(sotfd(whichRow,:));
index = find(abs(cyclesdegree) < plotLimitFreq);
plot(cyclesdegree(index),log10(onedSOTFH(index)),'b','LineWidth',2);
plot(cyclesdegree(index),log10(onedSOTFV(index)),'b:','LineWidth',2);
plot([autrusseauFigure11.sf_cpd],log10([autrusseauFigure11.Smtf_ees]),'bo','MarkerSize',8,'MarkerFaceColor','b');
plot(cyclesdegree(index),log10(onedSOTFD(index)),'k','LineWidth',1);
xlim([0 plotLimitFreq]);
ylim([-3 0]);
xlabel('Cycles/Degree');
ylabel('LOG10 OTF');
if (CIRCULARLYAVERAGE)
    title('Circularized S cone PSF');
else
    title('S cone OTF');
end
drawnow;

end

% Need to come back to this code and get it working.
%
% %% TEST2.  Optimize focus and add to the plot.
% %
% % This takes a long time.
% 
% 
% %Should be using sets/gets
% 
% wvfParams3 = wvf0;
% wvfParams3.coneWeights = [1 1 0];
% wvfParams3.criterionFraction = 0.9;
% 
% % This takes a long time and produces an error that could be fixed by BW,
% % but he is too lazy.
% %  Error using wvfGet (line 590)
% %   Must explicitly compute PSF on wvf structure before getting it.  Use wvfComputePSF
% 
% wvfParams3 = wvfComputeOptimizedConePSF(wvfParams3);
% 
% lpsfo = psfCenter(wvfParams3.conepsf(:,:,1));
% mpsfo = psfCenter(wvfParams3.conepsf(:,:,2));
% spsfo = psfCenter(wvfParams3.conepsf(:,:,3));
% if (CIRCULARLYAVERAGE)
%     lpsfo = psfCircularlyAverage(lpsfo);
%     mpsfo = psfCircularlyAverage(mpsfo);
%     spsfo = psfCircularlyAverage(spsfo);
% end
% onedLPSFo = lpsfo(whichRow,:);
% onedMPSFo = mpsfo(whichRow,:);
% onedSPSFo = spsfo(whichRow,:);
% 
% figure(theFig);
% subplot(1,3,1);
% plot(arcminutes(index),onedLPSFo(index),'r','LineWidth',4);
% subplot(1,3,2); hold on
% plot(arcminutes(index),onedMPSFo(index),'g','LineWidth',4);
% subplot(1,3,3); hold on
% plot(arcminutes(index),onedSPSFo(index),'b','LineWidth',4);
% drawnow;






##### SOURCE END #####
--></body></html>