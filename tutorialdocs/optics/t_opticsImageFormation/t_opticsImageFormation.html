
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>t_opticsImageFormation</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-12-17"><meta name="DC.source" content="t_opticsImageFormation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>t_opticsImageFormation</h1><!--introduction--><p>Tutorial on optics and image formation</p><p>Date:      01.02.96 Duration:  45 minutes</p><p>Matlab 5:  Checked 01.06.98, BW 01.07.99:  Added IjSpeert calls, BW 01.12.01   Added new graphs for ijspeert curves and Williams et al. data, BW 01.18.03   Started integration with vCamera-2.0, minor changes. 01.02.08   Verified with local files for single download - BW 06.29.15   Don't use rad2deg and deg2rad as variable names, since these            are Matlab functions.</p><p>NOTES:   1) This is a really nice tutorial and it runs.  But it relies on data   that are live under the scripts/optics directory.  We need to decide   how we're going to handle those .mat files, which are not in ISET data   format.  It would be nice to conver them to be so, and make the   idiosyncratic data go away.  (DHB)</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initialize</a></li><li><a href="#2">Visual Angle</a></li><li><a href="#3">The viewing geometry</a></li><li><a href="#4">In radians, the viewing angle, phi, satisfies tan(phi) = (opposite/adjacent).</a></li><li><a href="#5">The Westheimer linespread function</a></li><li><a href="#6">Another way to calculate and plot the Westheimer function</a></li><li><a href="#7">Convolution of the image and linespread</a></li><li><a href="#8">Defocus in the frequency domain</a></li><li><a href="#9">What happens to cosinusoids at different spatial frequencies.</a></li><li><a href="#10">Compare convolution and the Fourier Transform of the linespread function.</a></li><li><a href="#11">Comparison of the pointspread and linespread</a></li><li><a href="#12">Chromatic aberration:  How the linespread varies with wavelength</a></li><li><a href="#13">Chromatic aberration in the frequency domain</a></li><li><a href="#14">More modern Linespreads, Pointspreads, and MTFs</a></li><li><a href="#15">Comparison of the MTFs with the Williams data</a></li><li><a href="#16">What does the pointspread function look like in 2D?</a></li><li><a href="#17">End</a></li></ul></div><h2>Initialize<a name="1"></a></h2><pre class="codeinput">ieInit;
</pre><h2>Visual Angle<a name="2"></a></h2><p>To think about the effect of an image on the eye, we must specify the image in terms of degrees of visual angle.  As an example for how to compute spacing in terms of degrees of visual angle, consider a printer whose dots are spaced (dots per inch)</p><pre class="codeinput">dpi = 600

<span class="comment">% Suppose we read the paper at a viewing distance (inches)</span>
viewingDistance = 12
</pre><pre class="codeoutput">
dpi =

   600


viewingDistance =

    12

</pre><h2>The viewing geometry<a name="3"></a></h2><pre class="codeinput">vcNewGraphWin;
line([0 viewingDistance 0 0],[0 0 1 0]);
axis <span class="string">equal</span>
set(gca,<span class="string">'xlim'</span>,[-2 20]), grid <span class="string">on</span>
xlabel(<span class="string">'Viewing Distance (inch)'</span>)
ylabel(<span class="string">'Position between spots on paper (inch)'</span>)
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_01.png" style="width:717px;height:518px;" alt=""> <h2>In radians, the viewing angle, phi, satisfies tan(phi) = (opposite/adjacent).<a name="4"></a></h2><pre class="codeinput">deg2radFactor = 2*pi/360;
rad2degFactor = 360/(2*pi)
phi = atan(1/viewingDistance)*rad2degFactor

<span class="comment">% There are 600 dots per inch, so that each dot occupies</span>
DegPerDot = phi/dpi

<span class="comment">% There are 60 min of visual angle per deg,</span>
MinPerDot = 60*DegPerDot

<span class="comment">% And 60 sec of visual angle per min,</span>
SecPerDot = 60*MinPerDot

<span class="comment">% As you will see later in the course, experiments have shown that people</span>
<span class="comment">% can localize the position of a line to a spatial position of roughly 6</span>
<span class="comment">% sec of visual angle.  Hence, at this viewing distance and with this many</span>
<span class="comment">% dots per inch, the dot spacing is wider than the spacing that can be just</span>
<span class="comment">% discriminated by the human eye.</span>
</pre><pre class="codeoutput">
rad2degFactor =

  57.295779513082323


phi =

   4.763641690726177


DegPerDot =

   0.007939402817877


MinPerDot =

   0.476364169072618


SecPerDot =

  28.581850144357066

</pre><h2>The Westheimer linespread function<a name="5"></a></h2><p>Westheimer calculated that the linespread function of the human eye, specified in terms of minutes of arc and using a 3mm pupil, should be approximated using the following formula</p><p>LineSpread = 0.47*exp(-3.3 *(x.^2)) + 0.53*exp(-0.93*abs(x));</p><pre class="codeinput"><span class="comment">% Suppose we wish to plot the function by defining the spatial</span>
<span class="comment">% variable, x, in terms of seconds of arc,</span>
xSec = -300:1:300;
xMin = xSec/60;
ls = 0.47*exp(-3.3 *(xMin.^2)) + 0.53*exp(-0.93*abs(xMin));
ls = ls / sum(ls);

vcNewGraphWin;
plot(xSec,ls)
set(gca,<span class="string">'xlim'</span>,[-240 240],<span class="string">'xtick'</span>,(-240:60:240)), grid  <span class="string">on</span>
xlabel(<span class="string">'Arc sec'</span>), ylabel(<span class="string">'Responsivity'</span>), title(<span class="string">'Westheimer Linespread'</span>)

<span class="comment">% From our previous calculation, we observed that the dots in a 600 dpi</span>
<span class="comment">% printer, viewed at 12 inches, are spaced 28.5819 sec of visual angle</span>
<span class="comment">% apart.  At this distance, the linespread has fallen to about one-half of</span>
<span class="comment">% its peak value.</span>

<span class="comment">% Hence, if we could control the intensity and color of the printed dots --</span>
<span class="comment">% which we cannot do on conventional laser printers -- then at this viewing</span>
<span class="comment">% distance we would be able to produce images that were very realistic in</span>
<span class="comment">% their appearance.</span>
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_02.png" style="width:717px;height:518px;" alt=""> <h2>Another way to calculate and plot the Westheimer function<a name="6"></a></h2><pre class="codeinput">xSec = -300:300;    <span class="comment">% 600 sec, total = 10 min</span>
westheimerOTF = abs(fft(westheimerLSF(xSec)));

<span class="comment">% One cycle spans 10 min of arc, so freq=1 is 6 c/deg</span>
freq = [0:11]*6;
vcNewGraphWin;
semilogy(freq,westheimerOTF([1:12])); grid <span class="string">on</span>;
xlabel(<span class="string">'Freq (cpd)'</span>); ylabel(<span class="string">'Relative contrast'</span>);
set(gca,<span class="string">'ylim'</span>,[-.1 1.1])
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_03.png" style="width:717px;height:518px;" alt=""> <h2>Convolution of the image and linespread<a name="7"></a></h2><p>We can estimate the visual image created by an image printed at 600 dpi using the following simple convolution calculation. Let's create an image that spans 0.2 deg and has a dot every 30 sec. (i.e., roughly 28.58)</p><pre class="codeinput">dotSpacing = 30;
secPerDeg = 60*60;
x = 1:0.2*secPerDeg;
im = zeros(1,length(x));
im(1:dotSpacing:length(im)) = ones(size(im(1:dotSpacing:length(im))));

<span class="comment">% Here is an image showing the sampled line positions</span>
<span class="comment">% (The lines represent a printer dot)</span>
<span class="comment">%</span>
<span class="comment">% It is not immediately clear why the call to imshow throws a negative</span>
<span class="comment">% axis warning.  The plot looks fine.  So we just switch off the warning to</span>
<span class="comment">% avoid reducing the confidence of the user about the quality of our code.</span>
vcNewGraphWin;
S = warning(<span class="string">'off'</span>,<span class="string">'MATLAB:Axes:NegativeLimitsInLogAxis'</span>);
imshow(im(ones(1,128),1:512))
warning(S);
title(<span class="string">'Image of line stimulus'</span>);

<span class="comment">% Each line in the physical image adds a unit linespread to the retinal</span>
<span class="comment">% image.  We can compute the retinal image by forming the convolution of</span>
<span class="comment">% the image with the Westheimer linespread function.  Remember: we sampled</span>
<span class="comment">% the linespread once every sec of arc. So, we can simply convolve the</span>
<span class="comment">% image and the linespread function now as:</span>
retIm = conv2(ls,im,<span class="string">'full'</span>);

vcNewGraphWin;
plot(retIm),grid <span class="string">on</span>
title(<span class="string">'The one-dimensional retinal image'</span>)
xlabel(<span class="string">'Sec of arc'</span>), ylabel(<span class="string">'Image intensity'</span>)

<span class="comment">% (If the colors in the image look funny, make sure to place your</span>
<span class="comment">% cursor inside the window.  This may change the local color</span>
<span class="comment">% map).</span>

<span class="comment">% While the original image varies from black to white, after blurring by</span>
<span class="comment">% the eye's optics, there is only a small amount of residual variation in</span>
<span class="comment">% the retinal image.  Because of the blurring, the retinal image is much</span>
<span class="comment">% more likely the image of a bar than it is the image of a set of</span>
<span class="comment">% individual lines.</span>

<span class="comment">% In fact, the dots placed on the page are not perfect line samples.  Each</span>
<span class="comment">% ink line has some width.  So, a more realistic input image might be</span>
<span class="comment">% created by blurring the stimulus and then convolving with the linespread.</span>
gKernel = fspecial(<span class="string">'gaussian'</span>,[1,30],2);  <span class="comment">% This produces a little Gaussian window for filtering</span>
blurIm = conv2(im,gKernel,<span class="string">'full'</span>);
blurIm = ieScale(blurIm,1,32);
retIm = conv2(blurIm,ls,<span class="string">'full'</span>);

vcNewGraphWin;
imshow(blurIm(ones(1,128),1:512),[]);
title(<span class="string">'Image of line stimulus blurred by ink width'</span>);

<span class="comment">% Notice the very small ripples left in the curve after taking</span>
<span class="comment">% into account the blurring by the physical display and by the</span>
<span class="comment">% eye.</span>
vcNewGraphWin;
plot(retIm), axis <span class="string">square</span>, grid <span class="string">on</span>
title(<span class="string">'Retinal image of blurred lines'</span>)
xlabel(<span class="string">'Sec of arc'</span>), ylabel(<span class="string">'Intensity'</span>)

<span class="comment">% The question you might ask yourself now is this: will those</span>
<span class="comment">% small ripples be detectable by the observers?  How can we tell?</span>
<span class="comment">% You might also ask what will happen when we view the page at 6</span>
<span class="comment">% inches, or at 24 inches.  What if we increase the printer</span>
<span class="comment">% resolution to 1200 dpi?  What if we introduce some ability to</span>
<span class="comment">% modulate the density of the ink and hence the light scattered</span>
<span class="comment">% back to the eye?</span>
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_04.png" style="width:364px;height:129px;" alt=""> <img vspace="5" hspace="5" src="t_opticsImageFormation_05.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_opticsImageFormation_06.png" style="width:364px;height:129px;" alt=""> <img vspace="5" hspace="5" src="t_opticsImageFormation_07.png" style="width:717px;height:518px;" alt=""> <h2>Defocus in the frequency domain<a name="8"></a></h2><p>First, make a new linespread function that is smaller and easier to compute with.  Have it extend over 1 deg (60 min) so the Fourier Transform is easier to interpret</p><pre class="codeinput">xMin = -30:1:29;
ls = 0.47*exp(-3.3 *(xMin.^2)) + 0.53*exp(-0.93*abs(xMin));
ls = ls / sum(ls);

vcNewGraphWin;
plot(xMin,ls), grid <span class="string">on</span>
xlabel(<span class="string">'Min of arc'</span>),ylabel(<span class="string">'Linespread value'</span>)

<span class="comment">% Now, consider the retinal image that is formed by some simple</span>
<span class="comment">% harmonic functions.  Here is a sinusoid that varies at 1 cycle</span>
<span class="comment">% per degree of visual angle.</span>
nSamples = length(xMin);
f = 1;
harmonic = cos(2*pi*f*xMin/nSamples);

vcNewGraphWin;
plot(xMin,harmonic), grid <span class="string">on</span>
title(<span class="string">'Sampled cosinusoid'</span>)
xlabel(<span class="string">'Arc sec'</span>), ylabel(<span class="string">'Intensity'</span>)
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_08.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_opticsImageFormation_09.png" style="width:717px;height:518px;" alt=""> <h2>What happens to cosinusoids at different spatial frequencies.<a name="9"></a></h2><p>Notice that the amplitude of the cosinusoid falls off as the spatial frequency increases.  We will store the amplitude of the cosinusoid in the variable "peak".</p><pre class="codeinput">vcNewGraphWin;
freq =[1 5 10 15];
peak = zeros(1,length(freq));
<span class="keyword">for</span> i = 1:length(freq)
    harmonic = cos(2*pi*freq(i)*xMin/nSamples);
    retIm = convolvecirc(harmonic,ls);
    subplot(2,2,i)
    plot(retIm), grid <span class="string">on</span>, set(gca,<span class="string">'ylim'</span>,[-1 1],<span class="string">'xlim'</span>,[0 64]);
    xlabel(<span class="string">'Arc sec'</span>)
    peak(i) = max(retIm(:))
<span class="keyword">end</span>

<span class="comment">% We can plot the amplitude of the retinal cosinusoid, and its</span>
<span class="comment">% amplitude decreases with the input frequency.  I also use the</span>
<span class="comment">% fact that at f = 0 the amplitude = 1 (because the area under</span>
<span class="comment">% the linespread is 1).</span>
vcNewGraphWin;
plot([0 freq],[1 peak],<span class="string">'-'</span>)
set(gca,<span class="string">'ylim'</span>,[0 1])
xlabel(<span class="string">'Spatial freq (cpd)'</span>), ylabel(<span class="string">'Transfer'</span>)
grid <span class="string">on</span>
</pre><pre class="codeoutput">
peak =

  Columns 1 through 3

   0.991643632485555                   0                   0

  Column 4

                   0


peak =

  Columns 1 through 3

   0.991643632485555   0.838932018430419                   0

  Column 4

                   0


peak =

  Columns 1 through 3

   0.991643632485555   0.838932018430419   0.623187003057830

  Column 4

                   0


peak =

  Columns 1 through 3

   0.991643632485555   0.838932018430419   0.623187003057830

  Column 4

   0.496806481741752

</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_10.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_opticsImageFormation_11.png" style="width:717px;height:518px;" alt=""> <h2>Compare convolution and the Fourier Transform of the linespread function.<a name="10"></a></h2><pre class="codeinput"><span class="comment">% Remember, the linespread was built so that it spans 1 deg, hence</span>
<span class="comment">% frequency is in cycles per degree.</span>
mtf = abs(fft(ls));
hold <span class="string">on</span>, plot(freq,mtf(freq + 1),<span class="string">'ro'</span>);
hold <span class="string">off</span>

<span class="comment">% The values we obtain from convolution are plotted as solid line,</span>
<span class="comment">% whereas the amplitude of the Fourier Transform of the linespread</span>
<span class="comment">% function is plotted as a red circles at each frequency.</span>

<span class="comment">% The functions match, which should give you some intuition about</span>
<span class="comment">% what the amplitude of the Fourier Transform represents.</span>
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_12.png" style="width:717px;height:518px;" alt=""> <h2>Comparison of the pointspread and linespread<a name="11"></a></h2><pre class="codeinput"><span class="comment">% When working with two-dimensional inputs, we must consider the</span>
<span class="comment">% pointspread function, that is the response to an input that is</span>
<span class="comment">% a point of light. A standard formula for the cross-section of</span>
<span class="comment">% the pointspread function of the human eye for a 3mm pupil is</span>
<span class="comment">% also provided by Westheimer.  We can compare the linespread and</span>
<span class="comment">% the cross-section of the pointspread in the following graphs.</span>
xSec = -300:300;
xMin = xSec/60;
ls = 0.47*exp(-3.3 *(xMin.^2)) + 0.53*exp(-0.93*abs(xMin));
ps = 0.952*exp(-2.59*abs(xMin).^1.36) + 0.048*exp(-2.43*abs(xMin).^1.74);

vcNewGraphWin;
p = plot(xSec,ps,<span class="string">'r-'</span>,xSec,ls,<span class="string">'b--'</span>); grid <span class="string">on</span>
set(gca,<span class="string">'xlim'</span>,[-180 180])
xlabel(<span class="string">'Arc sec'</span>), ylabel(<span class="string">'LS or PS amplitude'</span>)
legend(p,<span class="string">'Pointspread'</span>,<span class="string">'Linespread'</span>)

<span class="comment">% Next, we can create a graph of the pointspread.  First, create</span>
<span class="comment">% a matrix whose entries are the distance from the origin</span>
xSec = -240:10:240;
xMin = xSec/60;
X = xMin(ones(1,length(xMin)),:); Y = X';
D = X.^2 + Y.^2; D = D.^0.5;

<span class="comment">% If you want to see the distance from the origin, you might show</span>
<span class="comment">% this image: colormap(gray(32)),imagesc(D), axis image</span>

<span class="comment">% Then, compute the pointspread function and make a picture of it</span>
ps = 0.952*exp(-2.59*abs(D).^1.36) + 0.048*exp(-2.43*abs(D).^1.74);
vcNewGraphWin;
colormap(cool(64)), mesh(ps)

<span class="comment">% To see the pointspread as an image, rather than as a mesh plot,</span>
<span class="comment">% you might make this figure: colormap(gray(32)),imagesc(ps), axis image</span>
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_13.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_opticsImageFormation_14.png" style="width:717px;height:518px;" alt=""> <h2>Chromatic aberration:  How the linespread varies with wavelength<a name="12"></a></h2><p>The linespread varies quite strongly with wavelength.  When the eye is in good focus at 580 nm (yellow-part of the spectrum) the light in the short-wavelength (400-450nm) is blurred quite strongly and light in the long-wavelength part of the spectrum is blurred, too, though somewhat less.  We can calculate the linespread as a function of wavelength (Marimont and Wandell, 1993) from basic principles.  The linespreads a various wavelengths are contained in the data file:</p><pre class="codeinput">oi = oiCreate(<span class="string">'human'</span>);
oi = oiSet(oi,<span class="string">'wavelength'</span>,370:730);
lsf = oiPlot(oi,<span class="string">'ls wavelength'</span>);

xDim = lsf.x;
lineSpread = lsf.lsWave;
wave = lsf.wavelength;

<span class="comment">% We select three wavelengths and plot their linespread functions</span>
<span class="comment">% together. Notice that for the shorter wavelength, the</span>
<span class="comment">% linespread function is much more spread-out than for the middle</span>
<span class="comment">% and long wavelengths.</span>
vcNewGraphWin;
plot(xDim, lineSpread(80, :), <span class="string">'b-'</span>, xDim, lineSpread(200,:), <span class="keyword">...</span>
      <span class="string">'g:'</span>, xDim, lineSpread(361, :), <span class="string">'r--'</span> );
legend(<span class="string">'wavelength 450'</span>, <span class="string">'wavelength 570'</span>,<span class="string">'wavelength 730'</span>);
xlabel(<span class="string">'Degrees'</span>); ylabel(<span class="string">'Image Intensity'</span>);
title(<span class="string">'Linespread functions for three wavelengths'</span>);

<span class="comment">%  Look at the line spread functions for all wavelengths</span>
lw = 1:10:length(wave);
vcNewGraphWin;
colormap(hot(32));
mesh(xDim, wave(lw), lineSpread(lw,:));
set(gca,<span class="string">'xlim'</span>,[-1 1],<span class="string">'ylim'</span>,[350 730])
ylabel(<span class="string">'wavelength (nm)'</span>); xlabel(<span class="string">'degrees'</span>); zlabel(<span class="string">'intensity'</span>);

<span class="comment">% Different wavelength components of an image are blurred to</span>
<span class="comment">% different extents by the eye.  We use a set of lines again as</span>
<span class="comment">% an example.  For this computation, we will assume that the</span>
<span class="comment">% input begins with equal energy at all wavelengths from 370 to</span>
<span class="comment">% 730 nm.</span>

<span class="comment">% Here, we create and display the image of sample lines.</span>
im = reshape([0 0 0 1 0 0 0 0]' * ones(1, 16), 1, 128);
imshow(im(ones(100,1), 1:128));

<span class="comment">% To calculate the retinal image for this pattern, we</span>
<span class="comment">% convolve each wavelength component of the image with the</span>
<span class="comment">% appropriate linespread function.  The routine conv2 takes the</span>
<span class="comment">% input image (im, size(im) = 1 128) and convolves it with each</span>
<span class="comment">% of the linespread functions in lineSpread size(lineSpread =</span>
<span class="comment">% 361,65).  This results in 361 images (one for each</span>
<span class="comment">% wavelength).</span>
retIm = conv2(im, lineSpread, <span class="string">'full'</span>);

<span class="comment">% We must remember the size (in deg) of each sample point this way.</span>
<span class="comment">%</span>
X = (-size(retIm,2)/2 : ((size(retIm, 2)/2) - 1)) / 64;

<span class="comment">% We can plot the retinal image corresponding to two wavelengths</span>
<span class="comment">% this way.</span>
vcNewGraphWin;
subplot(2,1,1)
plot(X,retIm(201,:),<span class="string">'g-'</span>)
set(gca,<span class="string">'ylim'</span>,[0 0.5])
title(sprintf(<span class="string">'Retinal Image for %d nm'</span>, wave(201)));
grid <span class="string">on</span>

subplot(2,1,2)
plot(X,retIm(51,:),<span class="string">'b-'</span>)
set(gca,<span class="string">'ylim'</span>,[0 0.5])
title(sprintf(<span class="string">'Retinal Image for %d nm'</span>, wave(51)));
grid <span class="string">on</span>

<span class="comment">% Notice that the two images have the same mean, they only differ</span>
<span class="comment">% in terms of the contrast:  the green image has a lot more</span>
<span class="comment">% contrast, but the same mean.</span>
mean(retIm(50,:),2)
mean(retIm(200,:),2)

<span class="comment">% The short wavelength (420 nm) component is blurred much more than</span>
<span class="comment">% the longer wavelength component of the image.  Hence, the image</span>
<span class="comment">% has very low amplitude ripples, and appears almost like a</span>
<span class="comment">% single, uniform bar.  The 570nm component, however, has high</span>
<span class="comment">% amplitude ripples that are quite distinct.  Hence, the</span>
<span class="comment">% short-wavelength variation would be very hard to detect in the</span>
<span class="comment">% retinal image, while the 570 nm component would be quite easy</span>
<span class="comment">% to detect.</span>
</pre><pre class="codeoutput">
ans =

   0.091101879397098


ans =

   0.090110466977327

</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_15.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_opticsImageFormation_16.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_opticsImageFormation_17.png" style="width:172px;height:115px;" alt=""> <img vspace="5" hspace="5" src="t_opticsImageFormation_18.png" style="width:717px;height:518px;" alt=""> <h2>Chromatic aberration in the frequency domain<a name="13"></a></h2><pre class="codeinput"><span class="comment">% Finally, let's make a few graphs of the modulation transfer</span>
<span class="comment">% function of the eye's optical system for individual</span>
<span class="comment">% wavelengths.  For short wavelength lights, high spatial</span>
<span class="comment">% frequency contrast is attenuated a lot by the optical path of</span>
<span class="comment">% the eye.</span>

<span class="comment">% OLD</span>
<span class="comment">% Load the MTFs for wavelengths from 370-730nm.  These were</span>
<span class="comment">% calculated using the methods in Marimont and Wandell that are</span>
<span class="comment">% in a script in the /local/class/psych221/tutorials/chromAb sub-directory.</span>
<span class="comment">% load combinedOtf;</span>
<span class="comment">% OLD</span>

cOTF = oiPlot(oi,<span class="string">'otf wavelength'</span>);
sampleSf = cOTF.fSupport;
combinedOtf = cOTF.otf;

<span class="comment">% Here is a graph of a few of the MTFs</span>
vcNewGraphWin;
plot(sampleSf, combinedOtf(:,81), <span class="string">'b-'</span>, <span class="keyword">...</span>
    sampleSf, combinedOtf(:,201), <span class="keyword">...</span>
    <span class="string">'g:'</span>, sampleSf, combinedOtf(:,361), <span class="string">'r--'</span> );
legend(<span class="string">'wavelength 450'</span>, <span class="string">'wavelength 570'</span>,<span class="string">'wavelength 730'</span>);
xlabel(<span class="string">'Frequency (CPD)'</span>); ylabel(<span class="string">'Scale factor'</span>); grid <span class="string">on</span>
title(<span class="string">'Modulation transfer functions for 3 wavelengths'</span>);

<span class="comment">% Notice that the amplitude of the short-wavelength becomes</span>
<span class="comment">% negative. This occurs because the blurring is so severe that</span>
<span class="comment">% the harmonic function is reproduced in the opposite phase</span>
<span class="comment">% compared to the input harmonic.  Hence, the amplitude is</span>
<span class="comment">% represented by a negative number.  This was illustrated in</span>
<span class="comment">% class using the slide projector, and the phenomenon is called</span>
<span class="comment">% "spurious resolution."</span>
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_19.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_opticsImageFormation_20.png" style="width:717px;height:518px;" alt=""> <h2>More modern Linespreads, Pointspreads, and MTFs<a name="14"></a></h2><p>In recent years, Ijspeert and others in the Netherlands developed a more extensive set of functions to predict the basic image formation variables in the average human eye.  The curves they derived were based on empirical inspection of data sets, and do not have any strong theoretical foundation. Still, they are probably more accurate than the Westheimer function and they are parameterized for the subject's age, pigmentation, and pupil diameter.  Hence, for practical computation, these are probably more useful.</p><pre class="codeinput"><span class="comment">% A student in Psych 221 developed the code to compute these</span>
<span class="comment">% values in the function "ijspeert."  Here is an example</span>
age = 20; 				    <span class="comment">% Subject's age</span>
pupil = 1.5; 				<span class="comment">% diameter in mm</span>
pigmentation = 0.142; 		<span class="comment">% Caucasian</span>
freqIndexRange = 1:50; 		<span class="comment">% The spatial frequency range</span>

<span class="comment">% Set the span to be 1 deg, so we know that 1 cycle in the MTF</span>
<span class="comment">% corresponds to 1 cycle per deg</span>
angleInDeg = (-.25:.005:.25);
angleInSec = angleInDeg*3600;
angleInRad = angleInDeg*deg2radFactor;

[iMTF, iPSF, iLSF] = ijspeert(age, pupil, pigmentation, <span class="keyword">...</span>
    freqIndexRange, angleInRad);

<span class="comment">% The functions should be normalized so that the area under the</span>
<span class="comment">% linespread and the first value of the MTF are one.</span>
iMTF = iMTF/iMTF(1);
iLSF = iLSF/sum(iLSF);

<span class="comment">% These are the modulation transfer function and linespread</span>
<span class="comment">% for the ijspeert data</span>
vcNewGraphWin; <span class="comment">%clf</span>
subplot(1,2,1), plot(iMTF); grid <span class="string">on</span>
set(gca,<span class="string">'xtick'</span>,(0:10:80),<span class="string">'xlim'</span>,[0 80]);
xlabel(<span class="string">'Spatial frequency (cpd)'</span>);
ylabel(<span class="string">'Amplitude'</span>);
title(<span class="string">'MTF'</span>)

<span class="comment">% Here is the linespread function</span>
subplot(1,2,2), plot(angleInSec,iLSF); grid <span class="string">on</span>
xlabel(<span class="string">'Position (sec)'</span>);
ylabel(<span class="string">'Intensity'</span>);
set(gca,<span class="string">'xtick'</span>,(-500:250:500),<span class="string">'xlim'</span>,[-500 500]);
title(<span class="string">'Line spread'</span>)

<span class="comment">% We can compare the ijspeert and westheimer linespread functions</span>
xMin = angleInSec/60;
ls = 0.47*exp(-3.3 *(xMin.^2)) + 0.53*exp(-0.93*abs(xMin));
ls = ls / sum(ls);
westMTF = abs(fft(ls));

clf
subplot(1,2,1)
plot(angleInSec/60,iLSF,<span class="string">'b-'</span>,angleInSec/60,ls,<span class="string">'r-'</span>)
set(gca,<span class="string">'xtick'</span>,(-8:2:8),<span class="string">'xlim'</span>,[-6 6]);
xlabel(<span class="string">'Position (min)'</span>), ylabel(<span class="string">'Intensity'</span>), title(<span class="string">'Linespread'</span>)
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_21.png" style="width:717px;height:518px;" alt=""> <h2>Comparison of the MTFs with the Williams data<a name="15"></a></h2><pre class="codeinput">load <span class="string">williams</span>

subplot(1,2,2)
n = length(iMTF);
freq = 0:(n-1);
plot(freq,iMTF(1:n),<span class="string">'b-'</span>,freq,westMTF(1:n),<span class="string">'r-'</span>)
hold <span class="string">on</span>
plot(dataF,dhb,<span class="string">'ro'</span>,dataF,drw,<span class="string">'go'</span>,dataF,rnb,<span class="string">'bo'</span>)
xlabel(<span class="string">'Spatial frequency (cpd)'</span>), ylabel(<span class="string">'Amplitude'</span>), title(<span class="string">'MTF'</span>)
set(gca,<span class="string">'ylim'</span>,[0 1])
grid <span class="string">on</span>
hold <span class="string">off</span>
legend(<span class="string">'Ijspeert'</span>,<span class="string">'Westheimer'</span>,<span class="string">'Data'</span>)
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_22.png" style="width:717px;height:518px;" alt=""> <h2>What does the pointspread function look like in 2D?<a name="16"></a></h2><pre class="codeinput"><span class="comment">% The PSF is circularly symmetric.  So, we can accumulate</span>
<span class="comment">% the 1D values into a 2D surface.</span>
<span class="comment">%</span>
angleInRad2D = linspace(min(angleInRad)/4,max(angleInRad)/4,length(angleInRad)/4);
nSamples = length(angleInRad2D);
[X,Y] = meshgrid(angleInRad2D,angleInRad2D);

<span class="comment">% Because the pointspread function is symmetric, we can calculate the value by</span>
<span class="comment">% building a matrix D that measures only the distance from the center of matrix.</span>
<span class="comment">% Try plotting this distance matrix using the command:</span>
<span class="comment">%</span>
<span class="comment">%   imagesc(D); colorbar; axis image</span>
D = sqrt(X.^2 + Y.^2);

<span class="comment">% Now, loop through the rows of D to calculate the pointspread values</span>
<span class="comment">% as a function of angle.</span>
iPSF2D = zeros(size(D));
<span class="keyword">for</span> ii=1:nSamples
   a = D(ii,:);
   [iMTF, iPSF2D(ii,:)] = ijspeert(age, pupil, pigmentation, <span class="keyword">...</span>
      freqIndexRange, a);
<span class="keyword">end</span>

vcNewGraphWin;
colormap(cool(64));
surf(angleInRad2D,angleInRad2D,iPSF2D);
</pre><img vspace="5" hspace="5" src="t_opticsImageFormation_23.png" style="width:717px;height:518px;" alt=""> <h2>End<a name="17"></a></h2><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% t_opticsImageFormation 
%
% Tutorial on optics and image formation
%
% Date:      01.02.96	
% Duration:  45 minutes
%	
% Matlab 5:  Checked 01.06.98, BW
% 01.07.99:  Added IjSpeert calls, BW
% 01.12.01   Added new graphs for ijspeert curves and Williams et al. data, BW
% 01.18.03   Started integration with vCamera-2.0, minor changes.
% 01.02.08   Verified with local files for single download - BW
% 06.29.15   Don't use rad2deg and deg2rad as variable names, since these
%            are Matlab functions.
%
% NOTES:
%   1) This is a really nice tutorial and it runs.  But it relies on data
%   that are live under the scripts/optics directory.  We need to decide
%   how we're going to handle those .mat files, which are not in ISET data
%   format.  It would be nice to conver them to be so, and make the
%   idiosyncratic data go away.  (DHB)

%% Initialize
ieInit;

%% Visual Angle
%
% To think about the effect of an image on the eye, we must specify the
% image in terms of degrees of visual angle.  As an example for how to
% compute spacing in terms of degrees of visual angle, consider a printer
% whose dots are spaced (dots per inch)
dpi = 600

% Suppose we read the paper at a viewing distance (inches)
viewingDistance = 12

%% The viewing geometry 
vcNewGraphWin;
line([0 viewingDistance 0 0],[0 0 1 0]); 
axis equal
set(gca,'xlim',[-2 20]), grid on
xlabel('Viewing Distance (inch)')
ylabel('Position between spots on paper (inch)')

%% In radians, the viewing angle, phi, satisfies tan(phi) = (opposite/adjacent).
deg2radFactor = 2*pi/360;
rad2degFactor = 360/(2*pi)
phi = atan(1/viewingDistance)*rad2degFactor

% There are 600 dots per inch, so that each dot occupies
DegPerDot = phi/dpi

% There are 60 min of visual angle per deg,
MinPerDot = 60*DegPerDot

% And 60 sec of visual angle per min,
SecPerDot = 60*MinPerDot

% As you will see later in the course, experiments have shown that people
% can localize the position of a line to a spatial position of roughly 6
% sec of visual angle.  Hence, at this viewing distance and with this many
% dots per inch, the dot spacing is wider than the spacing that can be just
% discriminated by the human eye.

%% The Westheimer linespread function
%
% Westheimer calculated that the linespread function of the human
% eye, specified in terms of minutes of arc and using a 3mm
% pupil, should be approximated using the following formula
%
% LineSpread = 0.47*exp(-3.3 *(x.^2)) + 0.53*exp(-0.93*abs(x));

% Suppose we wish to plot the function by defining the spatial
% variable, x, in terms of seconds of arc,
xSec = -300:1:300;	
xMin = xSec/60;
ls = 0.47*exp(-3.3 *(xMin.^2)) + 0.53*exp(-0.93*abs(xMin));
ls = ls / sum(ls);

vcNewGraphWin;
plot(xSec,ls)
set(gca,'xlim',[-240 240],'xtick',(-240:60:240)), grid  on
xlabel('Arc sec'), ylabel('Responsivity'), title('Westheimer Linespread')

% From our previous calculation, we observed that the dots in a 600 dpi
% printer, viewed at 12 inches, are spaced 28.5819 sec of visual angle
% apart.  At this distance, the linespread has fallen to about one-half of
% its peak value.

% Hence, if we could control the intensity and color of the printed dots REPLACE_WITH_DASH_DASH
% which we cannot do on conventional laser printers REPLACE_WITH_DASH_DASH then at this viewing
% distance we would be able to produce images that were very realistic in
% their appearance.

%% Another way to calculate and plot the Westheimer function
xSec = -300:300;    % 600 sec, total = 10 min
westheimerOTF = abs(fft(westheimerLSF(xSec)));

% One cycle spans 10 min of arc, so freq=1 is 6 c/deg
freq = [0:11]*6;
vcNewGraphWin; 
semilogy(freq,westheimerOTF([1:12])); grid on;
xlabel('Freq (cpd)'); ylabel('Relative contrast');
set(gca,'ylim',[-.1 1.1])

%% Convolution of the image and linespread
%
% We can estimate the visual image created by an image printed at 600 dpi
% using the following simple convolution calculation. Let's create an image
% that spans 0.2 deg and has a dot every 30 sec. (i.e., roughly 28.58)
dotSpacing = 30;
secPerDeg = 60*60;
x = 1:0.2*secPerDeg;
im = zeros(1,length(x));
im(1:dotSpacing:length(im)) = ones(size(im(1:dotSpacing:length(im))));

% Here is an image showing the sampled line positions
% (The lines represent a printer dot)
%
% It is not immediately clear why the call to imshow throws a negative
% axis warning.  The plot looks fine.  So we just switch off the warning to
% avoid reducing the confidence of the user about the quality of our code.
vcNewGraphWin;
S = warning('off','MATLAB:Axes:NegativeLimitsInLogAxis');
imshow(im(ones(1,128),1:512))
warning(S);
title('Image of line stimulus'); 

% Each line in the physical image adds a unit linespread to the retinal
% image.  We can compute the retinal image by forming the convolution of
% the image with the Westheimer linespread function.  Remember: we sampled
% the linespread once every sec of arc. So, we can simply convolve the
% image and the linespread function now as:
retIm = conv2(ls,im,'full');

vcNewGraphWin;
plot(retIm),grid on
title('The one-dimensional retinal image')
xlabel('Sec of arc'), ylabel('Image intensity')

% (If the colors in the image look funny, make sure to place your
% cursor inside the window.  This may change the local color
% map).

% While the original image varies from black to white, after blurring by
% the eye's optics, there is only a small amount of residual variation in
% the retinal image.  Because of the blurring, the retinal image is much
% more likely the image of a bar than it is the image of a set of
% individual lines. 

% In fact, the dots placed on the page are not perfect line samples.  Each
% ink line has some width.  So, a more realistic input image might be
% created by blurring the stimulus and then convolving with the linespread.
gKernel = fspecial('gaussian',[1,30],2);  % This produces a little Gaussian window for filtering
blurIm = conv2(im,gKernel,'full');
blurIm = ieScale(blurIm,1,32);
retIm = conv2(blurIm,ls,'full');

vcNewGraphWin;
imshow(blurIm(ones(1,128),1:512),[]);
title('Image of line stimulus blurred by ink width');

% Notice the very small ripples left in the curve after taking
% into account the blurring by the physical display and by the
% eye. 
vcNewGraphWin;
plot(retIm), axis square, grid on
title('Retinal image of blurred lines')
xlabel('Sec of arc'), ylabel('Intensity')

% The question you might ask yourself now is this: will those
% small ripples be detectable by the observers?  How can we tell?
% You might also ask what will happen when we view the page at 6
% inches, or at 24 inches.  What if we increase the printer
% resolution to 1200 dpi?  What if we introduce some ability to
% modulate the density of the ink and hence the light scattered
% back to the eye?

%% Defocus in the frequency domain
%
% First, make a new linespread function that is smaller and
% easier to compute with.  Have it extend over 1 deg (60 min) so
% the Fourier Transform is easier to interpret
xMin = -30:1:29;	
ls = 0.47*exp(-3.3 *(xMin.^2)) + 0.53*exp(-0.93*abs(xMin));
ls = ls / sum(ls);

vcNewGraphWin;
plot(xMin,ls), grid on
xlabel('Min of arc'),ylabel('Linespread value')

% Now, consider the retinal image that is formed by some simple
% harmonic functions.  Here is a sinusoid that varies at 1 cycle
% per degree of visual angle.
nSamples = length(xMin);
f = 1;
harmonic = cos(2*pi*f*xMin/nSamples);

vcNewGraphWin;
plot(xMin,harmonic), grid on
title('Sampled cosinusoid')
xlabel('Arc sec'), ylabel('Intensity')

%% What happens to cosinusoids at different spatial frequencies.  
%
% Notice that the amplitude of the cosinusoid falls off as the spatial
% frequency increases.  We will store the amplitude of the cosinusoid in
% the variable "peak".
vcNewGraphWin;
freq =[1 5 10 15]; 
peak = zeros(1,length(freq)); 
for i = 1:length(freq)
    harmonic = cos(2*pi*freq(i)*xMin/nSamples);
    retIm = convolvecirc(harmonic,ls);
    subplot(2,2,i)
    plot(retIm), grid on, set(gca,'ylim',[-1 1],'xlim',[0 64]);
    xlabel('Arc sec')
    peak(i) = max(retIm(:))
end

% We can plot the amplitude of the retinal cosinusoid, and its
% amplitude decreases with the input frequency.  I also use the
% fact that at f = 0 the amplitude = 1 (because the area under
% the linespread is 1).
vcNewGraphWin;
plot([0 freq],[1 peak],'-')
set(gca,'ylim',[0 1])
xlabel('Spatial freq (cpd)'), ylabel('Transfer')
grid on

%% Compare convolution and the Fourier Transform of the linespread function.  

% Remember, the linespread was built so that it spans 1 deg, hence
% frequency is in cycles per degree.
mtf = abs(fft(ls));
hold on, plot(freq,mtf(freq + 1),'ro');
hold off

% The values we obtain from convolution are plotted as solid line,
% whereas the amplitude of the Fourier Transform of the linespread
% function is plotted as a red circles at each frequency.

% The functions match, which should give you some intuition about
% what the amplitude of the Fourier Transform represents.

%% Comparison of the pointspread and linespread

% When working with two-dimensional inputs, we must consider the
% pointspread function, that is the response to an input that is
% a point of light. A standard formula for the cross-section of
% the pointspread function of the human eye for a 3mm pupil is
% also provided by Westheimer.  We can compare the linespread and
% the cross-section of the pointspread in the following graphs.
xSec = -300:300;
xMin = xSec/60;
ls = 0.47*exp(-3.3 *(xMin.^2)) + 0.53*exp(-0.93*abs(xMin));
ps = 0.952*exp(-2.59*abs(xMin).^1.36) + 0.048*exp(-2.43*abs(xMin).^1.74);

vcNewGraphWin;
p = plot(xSec,ps,'r-',xSec,ls,'bREPLACE_WITH_DASH_DASH'); grid on
set(gca,'xlim',[-180 180])
xlabel('Arc sec'), ylabel('LS or PS amplitude')
legend(p,'Pointspread','Linespread')

% Next, we can create a graph of the pointspread.  First, create
% a matrix whose entries are the distance from the origin
xSec = -240:10:240;
xMin = xSec/60;
X = xMin(ones(1,length(xMin)),:); Y = X';
D = X.^2 + Y.^2; D = D.^0.5;

% If you want to see the distance from the origin, you might show
% this image: colormap(gray(32)),imagesc(D), axis image

% Then, compute the pointspread function and make a picture of it
ps = 0.952*exp(-2.59*abs(D).^1.36) + 0.048*exp(-2.43*abs(D).^1.74);
vcNewGraphWin;
colormap(cool(64)), mesh(ps)

% To see the pointspread as an image, rather than as a mesh plot,
% you might make this figure: colormap(gray(32)),imagesc(ps), axis image

%% Chromatic aberration:  How the linespread varies with wavelength
%
% The linespread varies quite strongly with wavelength.  When the
% eye is in good focus at 580 nm (yellow-part of the spectrum)
% the light in the short-wavelength (400-450nm) is blurred quite
% strongly and light in the long-wavelength part of the spectrum
% is blurred, too, though somewhat less.  We can calculate the
% linespread as a function of wavelength (Marimont and Wandell,
% 1993) from basic principles.  The linespreads a various
% wavelengths are contained in the data file:
oi = oiCreate('human');
oi = oiSet(oi,'wavelength',370:730);
lsf = oiPlot(oi,'ls wavelength');

xDim = lsf.x;
lineSpread = lsf.lsWave;
wave = lsf.wavelength;

% We select three wavelengths and plot their linespread functions
% together. Notice that for the shorter wavelength, the
% linespread function is much more spread-out than for the middle
% and long wavelengths.
vcNewGraphWin;
plot(xDim, lineSpread(80, :), 'b-', xDim, lineSpread(200,:), ...
      'g:', xDim, lineSpread(361, :), 'rREPLACE_WITH_DASH_DASH' );
legend('wavelength 450', 'wavelength 570','wavelength 730');
xlabel('Degrees'); ylabel('Image Intensity');
title('Linespread functions for three wavelengths');

%  Look at the line spread functions for all wavelengths
lw = 1:10:length(wave);
vcNewGraphWin;
colormap(hot(32));
mesh(xDim, wave(lw), lineSpread(lw,:)); 
set(gca,'xlim',[-1 1],'ylim',[350 730])
ylabel('wavelength (nm)'); xlabel('degrees'); zlabel('intensity');

% Different wavelength components of an image are blurred to
% different extents by the eye.  We use a set of lines again as
% an example.  For this computation, we will assume that the
% input begins with equal energy at all wavelengths from 370 to
% 730 nm.

% Here, we create and display the image of sample lines.
im = reshape([0 0 0 1 0 0 0 0]' * ones(1, 16), 1, 128);
imshow(im(ones(100,1), 1:128));

% To calculate the retinal image for this pattern, we
% convolve each wavelength component of the image with the
% appropriate linespread function.  The routine conv2 takes the
% input image (im, size(im) = 1 128) and convolves it with each
% of the linespread functions in lineSpread size(lineSpread =
% 361,65).  This results in 361 images (one for each
% wavelength).  
retIm = conv2(im, lineSpread, 'full');

% We must remember the size (in deg) of each sample point this way.
% 
X = (-size(retIm,2)/2 : ((size(retIm, 2)/2) - 1)) / 64;

% We can plot the retinal image corresponding to two wavelengths
% this way.
vcNewGraphWin;
subplot(2,1,1)
plot(X,retIm(201,:),'g-')
set(gca,'ylim',[0 0.5])
title(sprintf('Retinal Image for %d nm', wave(201)));
grid on

subplot(2,1,2)
plot(X,retIm(51,:),'b-')
set(gca,'ylim',[0 0.5])
title(sprintf('Retinal Image for %d nm', wave(51)));
grid on

% Notice that the two images have the same mean, they only differ
% in terms of the contrast:  the green image has a lot more
% contrast, but the same mean.
mean(retIm(50,:),2)
mean(retIm(200,:),2)

% The short wavelength (420 nm) component is blurred much more than
% the longer wavelength component of the image.  Hence, the image
% has very low amplitude ripples, and appears almost like a
% single, uniform bar.  The 570nm component, however, has high
% amplitude ripples that are quite distinct.  Hence, the
% short-wavelength variation would be very hard to detect in the
% retinal image, while the 570 nm component would be quite easy
% to detect.

%% Chromatic aberration in the frequency domain

% Finally, let's make a few graphs of the modulation transfer
% function of the eye's optical system for individual
% wavelengths.  For short wavelength lights, high spatial
% frequency contrast is attenuated a lot by the optical path of
% the eye.

% OLD
% Load the MTFs for wavelengths from 370-730nm.  These were
% calculated using the methods in Marimont and Wandell that are
% in a script in the /local/class/psych221/tutorials/chromAb sub-directory.
% load combinedOtf;
% OLD

cOTF = oiPlot(oi,'otf wavelength');
sampleSf = cOTF.fSupport;
combinedOtf = cOTF.otf;

% Here is a graph of a few of the MTFs
vcNewGraphWin;
plot(sampleSf, combinedOtf(:,81), 'b-', ...
    sampleSf, combinedOtf(:,201), ...
    'g:', sampleSf, combinedOtf(:,361), 'rREPLACE_WITH_DASH_DASH' );
legend('wavelength 450', 'wavelength 570','wavelength 730');
xlabel('Frequency (CPD)'); ylabel('Scale factor'); grid on
title('Modulation transfer functions for 3 wavelengths');

% Notice that the amplitude of the short-wavelength becomes
% negative. This occurs because the blurring is so severe that
% the harmonic function is reproduced in the opposite phase
% compared to the input harmonic.  Hence, the amplitude is
% represented by a negative number.  This was illustrated in
% class using the slide projector, and the phenomenon is called
% "spurious resolution."

%% More modern Linespreads, Pointspreads, and MTFs 
%
% In recent years, Ijspeert and others in the Netherlands
% developed a more extensive set of functions to predict the
% basic image formation variables in the average human eye.  The
% curves they derived were based on empirical inspection of data
% sets, and do not have any strong theoretical foundation.
% Still, they are probably more accurate than the Westheimer
% function and they are parameterized for the subject's age,
% pigmentation, and pupil diameter.  Hence, for practical
% computation, these are probably more useful.

% A student in Psych 221 developed the code to compute these
% values in the function "ijspeert."  Here is an example
age = 20; 				    % Subject's age
pupil = 1.5; 				% diameter in mm
pigmentation = 0.142; 		% Caucasian
freqIndexRange = 1:50; 		% The spatial frequency range

% Set the span to be 1 deg, so we know that 1 cycle in the MTF
% corresponds to 1 cycle per deg 
angleInDeg = (-.25:.005:.25);
angleInSec = angleInDeg*3600;
angleInRad = angleInDeg*deg2radFactor;

[iMTF, iPSF, iLSF] = ijspeert(age, pupil, pigmentation, ...
    freqIndexRange, angleInRad);

% The functions should be normalized so that the area under the
% linespread and the first value of the MTF are one.
iMTF = iMTF/iMTF(1);
iLSF = iLSF/sum(iLSF);

% These are the modulation transfer function and linespread
% for the ijspeert data
vcNewGraphWin; %clf
subplot(1,2,1), plot(iMTF); grid on
set(gca,'xtick',(0:10:80),'xlim',[0 80]);
xlabel('Spatial frequency (cpd)');
ylabel('Amplitude');
title('MTF')

% Here is the linespread function
subplot(1,2,2), plot(angleInSec,iLSF); grid on
xlabel('Position (sec)');
ylabel('Intensity');
set(gca,'xtick',(-500:250:500),'xlim',[-500 500]);
title('Line spread')

% We can compare the ijspeert and westheimer linespread functions 
xMin = angleInSec/60;
ls = 0.47*exp(-3.3 *(xMin.^2)) + 0.53*exp(-0.93*abs(xMin));
ls = ls / sum(ls);
westMTF = abs(fft(ls));

clf
subplot(1,2,1)
plot(angleInSec/60,iLSF,'b-',angleInSec/60,ls,'r-')
set(gca,'xtick',(-8:2:8),'xlim',[-6 6]);
xlabel('Position (min)'), ylabel('Intensity'), title('Linespread')
grid on

%% Comparison of the MTFs with the Williams data 
load williams

subplot(1,2,2) 
n = length(iMTF);
freq = 0:(n-1);
plot(freq,iMTF(1:n),'b-',freq,westMTF(1:n),'r-')
hold on
plot(dataF,dhb,'ro',dataF,drw,'go',dataF,rnb,'bo')
xlabel('Spatial frequency (cpd)'), ylabel('Amplitude'), title('MTF')
set(gca,'ylim',[0 1])
grid on
hold off
legend('Ijspeert','Westheimer','Data')

%% What does the pointspread function look like in 2D?

% The PSF is circularly symmetric.  So, we can accumulate 
% the 1D values into a 2D surface.
%
angleInRad2D = linspace(min(angleInRad)/4,max(angleInRad)/4,length(angleInRad)/4);
nSamples = length(angleInRad2D);
[X,Y] = meshgrid(angleInRad2D,angleInRad2D);

% Because the pointspread function is symmetric, we can calculate the value by
% building a matrix D that measures only the distance from the center of matrix.  
% Try plotting this distance matrix using the command:
%
%   imagesc(D); colorbar; axis image
D = sqrt(X.^2 + Y.^2);

% Now, loop through the rows of D to calculate the pointspread values
% as a function of angle.
iPSF2D = zeros(size(D));
for ii=1:nSamples
   a = D(ii,:);
   [iMTF, iPSF2D(ii,:)] = ijspeert(age, pupil, pigmentation, ...
      freqIndexRange, a);
end

vcNewGraphWin;
colormap(cool(64));
surf(angleInRad2D,angleInRad2D,iPSF2D);

%% End


##### SOURCE END #####
--></body></html>