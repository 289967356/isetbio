
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>t_osTimeStep</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-12-11"><meta name="DC.source" content="t_osTimeStep.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Init</a></li><li><a href="#6">Plot the photon rate at the center of the optical image</a></li><li><a href="#7">Plot the eye movement sequence (different colors for different OIs)</a></li><li><a href="#8">Plot the LMS isomerizations</a></li><li><a href="#9">Plot the photocurrents</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> t_osTimeStep
</pre><pre class="codeinput"><span class="comment">%</span>
<span class="comment">% Demonstrate simulations using three different timebases, one for stimuli (based on stimulus refresh rate),</span>
<span class="comment">% one for absorptions and eye movements (based on coneMosaic.integrationTime), and a third one for</span>
<span class="comment">% outer segment current computations (based on os.timeStep)</span>
<span class="comment">% Also demonstrates usage of the computeForOISequence() method of @coneMosaic, which computes</span>
<span class="comment">% absorptions and photocurrents for a sequence of sequentially presented optical images with eye movements.</span>
<span class="comment">%</span>
<span class="comment">% NPC, ISETBIO TEAM, 2016</span>
<span class="comment">%</span>
</pre><h2>Init<a name="3"></a></h2><pre class="codeinput">ieInit;

<span class="comment">% Examine the effects of varying the integrationTime</span>
conditionSet = 1;

<span class="comment">% Examine effects of varying the response time interval (os.timeStep)</span>
<span class="comment">%conditionSet = 2;</span>

<span class="comment">% Examine and contrast the magnitudes of photon noise vs OS noise</span>
<span class="comment">%conditionSet = 3;</span>

<span class="comment">% Custom condition</span>
<span class="comment">%conditionSet = 4;</span>

condData = makeConditionSet(conditionSet);

<span class="comment">% Run all the conditions</span>
<span class="keyword">for</span> stimulusConditionIndex = 1:numel(condData)
    <span class="comment">% Get the condition data</span>
    c = condData{stimulusConditionIndex};

    <span class="comment">% Run the simulation for this condition</span>
    [theConeMosaic, theOIsequence, <span class="keyword">...</span>
        isomerizationRateSequence, photoCurrentSequence, <span class="keyword">...</span>
        oiTimeAxis, absorptionsTimeAxis, photoCurrentTimeAxis] = runSimulation(c.mosaicSize, c.meanLuminance, c.modulation, c.modulationRegion, c.stimulusSamplingInterval, c.integrationTime, c.osTimeStep, c.photonNoise, c.osNoise);

    <span class="comment">% Plot the results</span>
    plotEverything(theConeMosaic, theOIsequence, isomerizationRateSequence, photoCurrentSequence, oiTimeAxis, absorptionsTimeAxis, photoCurrentTimeAxis, stimulusConditionIndex, c);
<span class="keyword">end</span>
</pre><pre class="codeoutput">No current noise added.
No current noise added.
No current noise added.
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> [theConeMosaic, theOIsequence, <span class="keyword">...</span>
    isomerizationRateSequence, photoCurrentSequence, <span class="keyword">...</span>
    oiTimeAxis, absorptionsTimeAxis, photoCurrentTimeAxis] = runSimulation(mosaicSize, meanLuminance,  modulationGain, modulationRegion, stimulusSamplingInterval, integrationTime, osTimeStep, photonNoise, osNoise)

    <span class="comment">% Define the time axis for the simulation</span>
    minTime = -0.84;
    maxTime = 0.72;
    oiTimeAxis = minTime:stimulusSamplingInterval:maxTime;

    <span class="comment">% Compute the stimulus modulation function</span>
    stimulusRampTau = 0.18;
    modulationFunction = modulationGain * exp(-0.5*(oiTimeAxis/stimulusRampTau).^2);

    <span class="comment">% Generate a uniform field scene with desired mean luminance</span>
    <span class="keyword">if</span> (isnan(mosaicSize))
        FOV = 0.2;
    <span class="keyword">else</span>
        FOV = max(mosaicSize);
    <span class="keyword">end</span>
    theScene = uniformFieldSceneCreate(FOV, meanLuminance);

    <span class="comment">% Generate optics</span>
    noOptics = false;
    theOI = oiGenerate(noOptics);

    <span class="comment">% Generate the sequence of optical images</span>
    theOIsequence = oiSequenceGenerate(theScene, theOI, oiTimeAxis, modulationFunction, modulationRegion);

    <span class="comment">% Generate the cone mosaic with eye movements for theOIsequence</span>
    theConeMosaic = coneMosaicGenerate(mosaicSize, photonNoise, osNoise, integrationTime, osTimeStep);

    <span class="comment">% Generate eye movement sequence for all oi's</span>
    eyeMovementsNum = theOIsequence.maxEyeMovementsNumGivenIntegrationTime(theConeMosaic.integrationTime);
    theConeMosaic.emGenSequence(eyeMovementsNum);

    [absorptionsCountSequence, photoCurrentSequence] = <span class="keyword">...</span>
            theConeMosaic.computeForOISequence(theOIsequence, <span class="keyword">...</span>
            <span class="string">'currentFlag'</span>, true <span class="keyword">...</span>
            );
    absorptionsTimeAxis = theConeMosaic.timeAxis + theOIsequence.timeAxis(1);
    photoCurrentTimeAxis = absorptionsTimeAxis;

    <span class="comment">%theOIsequence.visualizeWithEyeMovementSequence(absorptionsTimeAxis);</span>

    <span class="comment">% Compute photon rate from photon count</span>
    isomerizationRateSequence = absorptionsCountSequence / theConeMosaic.integrationTime;
<span class="keyword">end</span>


<span class="comment">% ------- Helper functions --------</span>

<span class="keyword">function</span> theConeMosaic = coneMosaicGenerate(mosaicSize, photonNoise, osNoise, integrationTime, osTimeStep)
    <span class="comment">% Default human mosaic</span>
    theConeMosaic = coneMosaic;

    <span class="comment">% Adjust size</span>
    <span class="keyword">if</span> isnan(mosaicSize)
        <span class="comment">% Generate a human cone mosaic with 1L, 1M and 1S cone</span>
        theConeMosaic.rows = 1;
        theConeMosaic.cols = 3;
        theConeMosaic.pattern = [2 3 4];
    <span class="keyword">else</span>
        theConeMosaic.setSizeToFOV(mosaicSize);
    <span class="keyword">end</span>

    <span class="comment">% Set the noise</span>
    theConeMosaic.noiseFlag = photonNoise;

    <span class="comment">% Set the integrationTime</span>
    theConeMosaic.integrationTime = integrationTime;

    <span class="comment">% Generate the outer-segment object to be used by the coneMosaic</span>
    theOuterSegment = osLinear();
    theOuterSegment.noiseFlag = osNoise;

    <span class="comment">% Set a custom timeStep, for @osLinear we do not need the default 0.1 msec</span>
    theOuterSegment.timeStep = osTimeStep;

    <span class="comment">% Couple the outersegment object to the cone mosaic object</span>
    theConeMosaic.os = theOuterSegment;
<span class="keyword">end</span>


<span class="keyword">function</span> theOIsequence = oiSequenceGenerate(theScene, theOI, oiTimeAxis, modulationFunction, modulationType)
    <span class="comment">% Compute the background and modulated optical images</span>
    oiBackground = oiCompute(theOI, theScene);
    oiModulated  = oiBackground;

    <span class="keyword">if</span> strcmp(modulationType, <span class="string">'FULL'</span>)
        theOIsequence = oiSequence(oiBackground, oiModulated, oiTimeAxis, modulationFunction, <span class="string">'composition'</span>, <span class="string">'add'</span>);
    <span class="keyword">else</span>
        pos = oiGet(oiBackground, <span class="string">'spatial support'</span>, <span class="string">'microns'</span>);
        modulationRegion.radiusInMicrons = 0.75*max(pos(:));
        theOIsequence = oiSequence(oiBackground, oiModulated, oiTimeAxis, modulationFunction, <span class="string">'modulationRegion'</span>, modulationRegion);
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> theOI = oiGenerate(noOptics)
    <span class="comment">% Generate optics</span>
    <span class="keyword">if</span> (noOptics)
        theOI = oiCreate(<span class="string">'diffraction limited'</span>);
        optics = oiGet(theOI,<span class="string">'optics'</span>);
        optics = opticsSet(optics,<span class="string">'fnumber'</span>,0);
        optics = opticsSet(optics, <span class="string">'off axis method'</span>, <span class="string">'skip'</span>);
        theOI = oiSet(theOI,<span class="string">'optics'</span>, optics);
    <span class="keyword">else</span>
        theOI = oiCreate(<span class="string">'human'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> uniformScene = uniformFieldSceneCreate(FOV, meanLuminance)
    uniformScene = sceneCreate(<span class="string">'uniform equal photon'</span>, 128);
    <span class="comment">% square scene with desired FOV</span>
    uniformScene = sceneSet(uniformScene, <span class="string">'wAngular'</span>, FOV);
    <span class="comment">% 1 meter away</span>
    uniformScene = sceneSet(uniformScene, <span class="string">'distance'</span>, 1.0);
    <span class="comment">% adjust radiance according to desired  mean luminance</span>
    uniformScene = sceneAdjustLuminance(uniformScene, meanLuminance);
<span class="keyword">end</span>


<span class="keyword">function</span> plotEverything(theConeMosaic, theOIsequence, isomerizationRateSequence, photoCurrentSequence, oiTimeAxis, absorptionsTimeAxis, responseTimeAxis, figNo, condData)
</pre><pre class="codeinput">    <span class="comment">% Plot the sequence of OIs with the eye movements</span>
    hFig = figure(figNo); clf;
    set(hFig, <span class="string">'Position'</span>, [10+figNo*50 10+figNo*100 1920 760], <span class="string">'Color'</span>, [1 1 1]);
    set(hFig, <span class="string">'Name'</span>, sprintf(<span class="string">'Scene Mean Luminance: %2.1f cd/m2,     Modulation: %2.2f,     Stimulus Sampling: %2.1f ms,     Integration Time: %2.1f ms,   osTimeStep: %2.1f ms,      PhotonNoise: %s,      osNoise: %s'</span>, condData.meanLuminance, condData.modulation, condData.stimulusSamplingInterval*1000, condData.integrationTime*1000, condData.osTimeStep*1000, condData.photonNoise, condData.osNoise));

    tabGroup = uitabgroup(<span class="string">'Parent'</span>, hFig);

    eyeMovementsTab = uitab(tabGroup, <span class="string">'Title'</span>, <span class="string">'2D eye movements and OI sequence'</span>, <span class="string">'BackgroundColor'</span>, [1 1 1], <span class="string">'ForegroundColor'</span>, [0 0 1]);
    timeSeriesTab = uitab(tabGroup, <span class="string">'Title'</span>, <span class="string">'Time series: optical image photon rate, eye movements, aborptions, &amp; photocurrents'</span>, <span class="string">'BackgroundColor'</span>, [1 1 1], <span class="string">'ForegroundColor'</span>, [0 0 1]);

    set(tabGroup, <span class="string">'SelectedTab'</span>,eyeMovementsTab);
    axes(<span class="string">'parent'</span>,eyeMovementsTab);


    plotRows = round(0.75*sqrt(theOIsequence.length));
    plotCols = ceil(theOIsequence.length/plotRows);
    subplotPosVectors = NicePlot.getSubPlotPosVectors(<span class="keyword">...</span>
           <span class="string">'rowsNum'</span>, plotRows, <span class="keyword">...</span>
           <span class="string">'colsNum'</span>, plotCols, <span class="keyword">...</span>
           <span class="string">'heightMargin'</span>,   0.03, <span class="keyword">...</span>
           <span class="string">'widthMargin'</span>,    0.03, <span class="keyword">...</span>
           <span class="string">'leftMargin'</span>,     0.03, <span class="keyword">...</span>
           <span class="string">'rightMargin'</span>,    0.00, <span class="keyword">...</span>
           <span class="string">'bottomMargin'</span>,   0.03, <span class="keyword">...</span>
           <span class="string">'topMargin'</span>,      0.02);

    maxRGB = 0;
    <span class="keyword">for</span> oiIndex = 1:theOIsequence.length
        tmp = xyz2rgb(oiGet(theOIsequence.frameAtIndex(oiIndex), <span class="string">'xyz'</span>));
        <span class="keyword">if</span> (maxRGB &lt; max(tmp(:)))
            maxRGB = max(tmp(:));
        <span class="keyword">end</span>
         oiImage{oiIndex} = tmp;
    <span class="keyword">end</span>

    <span class="comment">% Retrieve the eye movement sequence</span>
    eyeMovementSequence = theConeMosaic.emPositions;

    <span class="keyword">for</span> oiIndex = 1:theOIsequence.length
        pos = oiGet(theOIsequence.frameAtIndex(oiIndex), <span class="string">'spatial support'</span>, <span class="string">'microns'</span>);
        oiXaxis = pos(1,:,1); oiYaxis = pos(:,1,2);
        r = floor((oiIndex-1)/plotCols)+1;
        c = mod((oiIndex-1), plotCols)+1;
        subplot(<span class="string">'Position'</span>, subplotPosVectors(r,c).v);

        <span class="comment">% Plot the OI</span>
        imagesc(oiXaxis, oiYaxis, oiImage{oiIndex}/maxRGB);
        <span class="comment">% Overlay the eye movements up to this point</span>
        hold <span class="string">on</span>;
        idx = find(absorptionsTimeAxis &lt; oiTimeAxis(oiIndex));
        plot(eyeMovementSequence(idx,1)*theConeMosaic.pigment.width*1e6, eyeMovementSequence(idx,2)*theConeMosaic.pigment.width*1e6, <span class="string">'ks-'</span>, <span class="string">'LineWidth'</span>, 1.5, <span class="string">'MarkerFaceColor'</span>, [0.3 0.3 0.3]);
        <span class="keyword">if</span> (oiIndex &lt; theOIsequence.length)
            idx = find((absorptionsTimeAxis&gt;=oiTimeAxis(oiIndex)) &amp; (absorptionsTimeAxis&lt;oiTimeAxis(oiIndex+1)));
        <span class="keyword">else</span>
            idx = find((absorptionsTimeAxis&gt;=oiTimeAxis(oiIndex)));
        <span class="keyword">end</span>
        <span class="comment">% Emphasize in red, the eye movements for the current framer</span>
        plot(eyeMovementSequence(idx,1)*theConeMosaic.pigment.width*1e6, eyeMovementSequence(idx,2)*theConeMosaic.pigment.width*1e6, <span class="string">'rs-'</span>, <span class="string">'LineWidth'</span>, 1.5, <span class="string">'MarkerFaceColor'</span>, [1.0 0.5 0.5]);

        <span class="comment">% overlay the cone mosaic</span>
        <span class="keyword">if</span> (oiIndex == 1)
            plot(theConeMosaic.coneLocs(:,1)*1e6, theConeMosaic.coneLocs(:,2)*1e6, <span class="string">'k.'</span>);
        <span class="keyword">end</span>

        axis <span class="string">'image'</span>; axis <span class="string">'xy'</span>;
        set(gca, <span class="string">'CLim'</span>, [0 1], <span class="string">'FontSize'</span>, 14);
        <span class="keyword">if</span> ~((r == plotRows) &amp;&amp; (c == 1))
            set(gca, <span class="string">'XTick'</span>, [], <span class="string">'YTick'</span>, []);
        <span class="keyword">end</span>
        title(sprintf(<span class="string">'t: %2.1f msec'</span>, 1000*oiTimeAxis(oiIndex)), <span class="string">'FontSize'</span>, 14);
    <span class="keyword">end</span>

    <span class="comment">% Plot time-series responses</span>
    set(tabGroup, <span class="string">'SelectedTab'</span>,timeSeriesTab);
    axes(<span class="string">'parent'</span>,timeSeriesTab);
</pre><img vspace="5" hspace="5" src="t_osTimeStep_01.png" style="width:1920px;height:760px;" alt=""> <img vspace="5" hspace="5" src="t_osTimeStep_06.png" style="width:1920px;height:760px;" alt=""> <img vspace="5" hspace="5" src="t_osTimeStep_11.png" style="width:1920px;height:760px;" alt=""> <h2>Plot the photon rate at the center of the optical image<a name="6"></a></h2><pre class="codeinput">    subplot(<span class="string">'Position'</span>, [0.03 0.07 0.18 0.89]);
    oiWavelengthAxis = oiGet(theOIsequence.frameAtIndex(1), <span class="string">'wave'</span>);
    referencePositionOpticalImagePhotons = zeros(numel(oiWavelengthAxis), theOIsequence.length);
    <span class="keyword">for</span> oiIndex = 1:theOIsequence.length
        retinalPhotonsAtCurrentFrame = oiGet(theOIsequence.frameAtIndex(oiIndex), <span class="string">'photons'</span>);
        refRow = round(size(retinalPhotonsAtCurrentFrame,1)/2);
        refCol = round(size(retinalPhotonsAtCurrentFrame,2)/2);
        referencePositionOpticalImagePhotons(:, oiIndex) = squeeze(retinalPhotonsAtCurrentFrame(refRow, refCol, :));
    <span class="keyword">end</span>
    hP = pcolor(oiTimeAxis, oiWavelengthAxis, referencePositionOpticalImagePhotons);
    set(hP, <span class="string">'EdgeColor'</span>, <span class="string">'none'</span>);
    hold <span class="string">on</span>;
    <span class="comment">% Plot the total photons (summed across all wavelengths)</span>
    totalPhotons = sum(referencePositionOpticalImagePhotons,1);
    totalPhotonsNorm = oiWavelengthAxis(1) + (oiWavelengthAxis(end)-oiWavelengthAxis(1))*(totalPhotons-min(totalPhotons))/(max(totalPhotons)-min(totalPhotons));
    stairs(oiTimeAxis, totalPhotonsNorm, <span class="string">'c-'</span>, <span class="string">'LineWidth'</span>, 2.0);
    plotStimulusTimes([min(totalPhotonsNorm) max(totalPhotonsNorm)]);

    hold <span class="string">off</span>; box <span class="string">on</span>
    set(gca, <span class="string">'YLim'</span>, [oiWavelengthAxis(1) oiWavelengthAxis(end)], <span class="string">'XLim'</span>, [oiTimeAxis(1) oiTimeAxis(end)], <span class="string">'FontSize'</span>, 14);
    xlabel(<span class="string">'time (seconds)'</span>, <span class="string">'FontSize'</span>, 14, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
    ylabel(<span class="string">'wavelength (nm)'</span>, <span class="string">'FontSize'</span>, 14, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
    title(<span class="string">'optical image photon rate (image center)'</span>, <span class="string">'FontSize'</span>, 14);
    hC = colorbar(<span class="string">'Location'</span>, <span class="string">'NorthOutside'</span>, <span class="string">'parent'</span>, timeSeriesTab);
    hC.FontSize =  14;
    hC.Label.String = <span class="string">'photons/sec'</span>;
    axis <span class="string">'xy'</span>
    colormap(gray(1024));
</pre><img vspace="5" hspace="5" src="t_osTimeStep_02.png" style="width:1920px;height:760px;" alt=""> <img vspace="5" hspace="5" src="t_osTimeStep_07.png" style="width:1920px;height:760px;" alt=""> <img vspace="5" hspace="5" src="t_osTimeStep_12.png" style="width:1920px;height:760px;" alt=""> <h2>Plot the eye movement sequence (different colors for different OIs)<a name="7"></a></h2><pre class="codeinput">    subplot(<span class="string">'Position'</span>, [0.25 0.07 0.22 0.89]); hold <span class="string">on</span>;
    eyeMovementRange = [-100 100];

    plot(absorptionsTimeAxis, eyeMovementSequence(:,1)*theConeMosaic.pigment.width*1e6, <span class="string">'.'</span>, <span class="string">'MarkerSize'</span>, 15, <span class="string">'Color'</span>, <span class="string">'r'</span>);
    hold <span class="string">on</span>;
    plot(absorptionsTimeAxis, eyeMovementSequence(:,2)*theConeMosaic.pigment.height*1e6, <span class="string">'.'</span>, <span class="string">'MarkerSize'</span>, 15, <span class="string">'Color'</span>, <span class="string">'b'</span>);
    plotStimulusTimes(eyeMovementRange);

    box <span class="string">on</span>
    set(gca, <span class="string">'YLim'</span>, [eyeMovementRange(1) eyeMovementRange(end)], <span class="string">'XLim'</span>, [oiTimeAxis(1) oiTimeAxis(end)], <span class="string">'FontSize'</span>, 14);
    legend({<span class="string">'eye position (X)'</span>, <span class="string">'eye position (Y)'</span>});
    ylabel(<span class="string">'X,Y eye position (microns)'</span>, <span class="string">'FontSize'</span>, 14, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
    xlabel(<span class="string">'time (seconds)'</span>, <span class="string">'FontSize'</span>, 14, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
    title(<span class="string">'X,Y eye movements'</span>, <span class="string">'FontSize'</span>, 14);
</pre><img vspace="5" hspace="5" src="t_osTimeStep_03.png" style="width:1920px;height:760px;" alt=""> <img vspace="5" hspace="5" src="t_osTimeStep_08.png" style="width:1920px;height:760px;" alt=""> <img vspace="5" hspace="5" src="t_osTimeStep_13.png" style="width:1920px;height:760px;" alt=""> <h2>Plot the LMS isomerizations<a name="8"></a></h2><pre class="codeinput">    <span class="keyword">if</span> (theConeMosaic.rows ==1) &amp;&amp; (theConeMosaic.cols == 3)
       referenceConeRows = [1 1 1]; referenceConeCols = [1 2 3];
    <span class="keyword">else</span>
       <span class="comment">% Find the (row,col) coords of the center-most L, M and S-cone</span>
       <span class="keyword">for</span> k = 1:3
            coneIndices = find(theConeMosaic.pattern == k+1);
            [~, idx] = min(sum((theConeMosaic.coneLocs(coneIndices,:)).^2, 2));
            [referenceConeRows(k), referenceConeCols(k)] = ind2sub(size(theConeMosaic.pattern), coneIndices(idx));
       <span class="keyword">end</span>
    <span class="keyword">end</span>
    subplot(<span class="string">'Position'</span>, [0.50 0.07 0.22 0.89]);
    isomerizationRange = [min(isomerizationRateSequence(:)) 1.05*max(isomerizationRateSequence(:))];
    hold  <span class="string">on</span>
    coneColors = [1 0 0; 0 1 0; 0 0 1];
    <span class="keyword">for</span> k = 1:3
        plot(absorptionsTimeAxis, squeeze(isomerizationRateSequence(1, referenceConeRows(k),referenceConeCols(k),:)), <span class="string">'.'</span>, <span class="string">'Color'</span>, squeeze(coneColors(k,:)), <span class="string">'MarkerSize'</span>, 15, <span class="string">'LineWidth'</span>, 1.5);
    <span class="keyword">end</span>
    plotStimulusTimes(isomerizationRange);

    hold <span class="string">off</span>;
    set(gca, <span class="string">'YLim'</span>, isomerizationRange, <span class="string">'XLim'</span>, [oiTimeAxis(1) oiTimeAxis(end)], <span class="string">'FontSize'</span>, 14);
    ylabel(<span class="string">'isomerization rate (R*/cone/sec)'</span>, <span class="string">'FontSize'</span>, 14, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
    xlabel(<span class="string">'time (seconds)'</span>, <span class="string">'FontSize'</span>, 14, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
    title(<span class="string">'L,M,S-cone isomerization rates'</span>, <span class="string">'FontSize'</span>, 14);
</pre><img vspace="5" hspace="5" src="t_osTimeStep_04.png" style="width:1920px;height:760px;" alt=""> <img vspace="5" hspace="5" src="t_osTimeStep_09.png" style="width:1920px;height:760px;" alt=""> <img vspace="5" hspace="5" src="t_osTimeStep_14.png" style="width:1920px;height:760px;" alt=""> <h2>Plot the photocurrents<a name="9"></a></h2><pre class="codeinput">    subplot(<span class="string">'Position'</span>, [0.75 0.07 0.22 0.89]);
    photoCurrentRange = [min(photoCurrentSequence(:)) max(photoCurrentSequence(:))+2];
    hold <span class="string">on</span>;
    <span class="keyword">for</span> k = 1:3
        plot(responseTimeAxis, squeeze(photoCurrentSequence(1, referenceConeRows(k),referenceConeCols(k),:)), <span class="string">'k.'</span>, <span class="string">'Color'</span>, squeeze(coneColors(k,:)), <span class="string">'MarkerSize'</span>, 15, <span class="string">'LineWidth'</span>, 1.5);
    <span class="keyword">end</span>
    plotStimulusTimes(photoCurrentRange);

    hold <span class="string">off</span>;
    set(gca, <span class="string">'XLim'</span>, [oiTimeAxis(1) oiTimeAxis(end)], <span class="string">'YLim'</span>, photoCurrentRange, <span class="string">'FontSize'</span>, 14);
    ylabel(<span class="string">'photocurrent (pA)'</span>, <span class="string">'FontSize'</span>, 14, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
    xlabel(<span class="string">'time (seconds)'</span>, <span class="string">'FontSize'</span>, 14, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
    title(<span class="string">'@osLinear response'</span>, <span class="string">'FontSize'</span>, 14);

    <span class="comment">% Switch to eye movements tab</span>
    set(tabGroup, <span class="string">'SelectedTab'</span>,eyeMovementsTab);

    drawnow

    <span class="keyword">function</span> plotStimulusTimes(signalRange)
        <span class="comment">% Plot lines demarkating each OI time duration</span>
        <span class="keyword">for</span> oiIndex = 1:theOIsequence.length
            plot(oiTimeAxis(oiIndex)*[1 1], signalRange, <span class="string">'k-'</span>);
        <span class="keyword">end</span>
        <span class="comment">% Plot the origin in magenta</span>
        plot([0 0], signalRange, <span class="string">'-'</span>, <span class="string">'Color'</span>, [0.7 0.1 0.3], <span class="string">'LineWidth'</span>, 2);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="t_osTimeStep_05.png" style="width:1920px;height:760px;" alt=""> <img vspace="5" hspace="5" src="t_osTimeStep_10.png" style="width:1920px;height:760px;" alt=""> <img vspace="5" hspace="5" src="t_osTimeStep_15.png" style="width:1920px;height:760px;" alt=""> <pre class="codeinput"><span class="keyword">end</span>


<span class="keyword">function</span> condData = makeConditionSet(conditionSet)

    <span class="comment">% scene mean luminance</span>
    meanLuminance = 1500;

    <span class="comment">% Assemble conditions to run.</span>
    condData = {};

    <span class="keyword">switch</span> conditionSet

        <span class="comment">% Effects of varying the integrationTime</span>
        <span class="keyword">case</span> 1
            <span class="comment">% Steady params</span>
            c0 = struct(<span class="keyword">...</span>
                <span class="string">'mosaicSize'</span>, nan, <span class="keyword">...</span><span class="comment">                      % 1 L-, 1 M-, and 1 S-cone only</span>
                <span class="string">'meanLuminance'</span>, meanLuminance, <span class="keyword">...</span><span class="comment">         % scene mean luminance</span>
                <span class="string">'modulation'</span>, 0.5, <span class="keyword">...</span><span class="comment">                      % 50%  modulation against background</span>
                <span class="string">'modulationRegion'</span>, <span class="string">'CENTER'</span>, <span class="keyword">...</span><span class="comment">           % modulate the central image (choose b/n 'FULL', and 'CENTER')</span>
                <span class="string">'stimulusSamplingInterval'</span>,  1/50, <span class="keyword">...</span><span class="comment">      % 50 Hz stimulus refresh, e.g., 20 msec per optical image</span>
                <span class="string">'osTimeStep'</span>, 0.1/1000, <span class="keyword">...</span><span class="comment">                 % 0.1 millisecond</span>
                <span class="string">'integrationTime'</span>, nan, <span class="keyword">...</span><span class="comment">                 % we will vary this one</span>
                <span class="string">'photonNoise'</span>, <span class="string">'random'</span>, <span class="keyword">...</span><span class="comment">                % select from {'random', 'frozen', 'none'}</span>
                <span class="string">'osNoise'</span>, <span class="string">'none'</span>);                         <span class="comment">% select from {'random', 'frozen', 'none'}</span>

            <span class="comment">% Varied params</span>
            c0.integrationTime = 100/1000;                  <span class="comment">% 100 ms (longer than the stimulus sampling interval, so &lt; 1 eye movement / oi)</span>
            condData{numel(condData)+1} = c0;

            c0.integrationTime = 10/1000;                   <span class="comment">% 10 ms (smaller than the stimulus sampling interval, 2 eye movements / oi)</span>
            condData{numel(condData)+1} = c0;

            c0.integrationTime = 1/1000;                    <span class="comment">% 1 ms (20 eye movements / oi)</span>
            condData{numel(condData)+1} = c0;

        <span class="comment">% Examine effects of varying the os.timeStep</span>
        <span class="keyword">case</span> 2
            <span class="comment">% Steady params</span>
            c0 = struct(<span class="keyword">...</span>
                <span class="string">'mosaicSize'</span>, nan, <span class="keyword">...</span><span class="comment">                      % 1 L-, 1 M-, and 1 S-cone only</span>
                <span class="string">'meanLuminance'</span>, meanLuminance, <span class="keyword">...</span><span class="comment">         % scene mean luminance</span>
                <span class="string">'modulation'</span>, 0.5, <span class="keyword">...</span><span class="comment">                      % 50%  modulation against background</span>
                <span class="string">'modulationRegion'</span>, <span class="string">'CENTER'</span>, <span class="keyword">...</span><span class="comment">           % modulate the central image (choose b/n 'FULL', and 'CENTER')</span>
                <span class="string">'stimulusSamplingInterval'</span>,  1/10, <span class="keyword">...</span><span class="comment">      % 100 Hz stimulus refresh</span>
                <span class="string">'integrationTime'</span>, 20/1000, <span class="keyword">...</span><span class="comment">             % 20 milliseconds</span>
                <span class="string">'osTimeStep'</span>, nan, <span class="keyword">...</span><span class="comment">                      % we'll vary that one</span>
                <span class="string">'photonNoise'</span>, <span class="string">'random'</span>, <span class="keyword">...</span><span class="comment">                    % select from {'random', 'frozen', 'none'}</span>
                <span class="string">'osNoise'</span>, <span class="string">'none'</span>);                         <span class="comment">% select from {'random', 'frozen', 'none'}</span>

            <span class="comment">% Varied params</span>
            c0.osTimeStep = 1/1000;                    <span class="comment">% 1 milliseconds</span>
            condData{numel(condData)+1} = c0;

            c0.osTimeStep = 0.5/1000;                  <span class="comment">% 0.5 milliseconds</span>
            condData{numel(condData)+1} = c0;

            c0.osTimeStep = 0.1/1000;                  <span class="comment">% 0.1 milliseconds</span>
            condData{numel(condData)+1} = c0;



        <span class="comment">% Examine and contrast the magnitudes of photon noise vs OS noise</span>
        <span class="keyword">case</span> 3

            stimulusRefreshRateInHz = 25;
            eyeMovementsPerStimulusRefresh = 6;

            <span class="comment">% Steady params</span>
            c0 = struct(<span class="keyword">...</span>
                <span class="string">'mosaicSize'</span>, nan, <span class="keyword">...</span><span class="comment">                      % 1 L-, 1 M-, and 1 S-cone only</span>
                <span class="string">'meanLuminance'</span>, meanLuminance, <span class="keyword">...</span><span class="comment">         % scene mean luminance</span>
                <span class="string">'modulation'</span>, 0.5, <span class="keyword">...</span><span class="comment">                      % % modulation against background</span>
                <span class="string">'modulationRegion'</span>, <span class="string">'CENTER'</span>, <span class="keyword">...</span><span class="comment">           % modulate the center only  (choose b/n 'FULL', and 'CENTER')</span>
                <span class="string">'stimulusSamplingInterval'</span>,  1/stimulusRefreshRateInHz, <span class="keyword">...</span>
                <span class="string">'integrationTime'</span>, 5/1000, <span class="keyword">...</span><span class="comment">             % 5 milliseconds</span>
                <span class="string">'osTimeStep'</span>, 0.1/1000, <span class="keyword">...</span>
                <span class="string">'photonNoise'</span>, nan, <span class="keyword">...</span>
                <span class="string">'osNoise'</span>, nan);

            <span class="comment">% Varied params</span>
            <span class="comment">% No noise</span>
            c0.photonNoise = <span class="string">'none'</span>;        <span class="comment">% select from {'random', 'frozen', 'none'}</span>
            c0.osNoise = <span class="string">'none'</span>;            <span class="comment">% select from {'random', 'frozen', 'none'}</span>
            condData{numel(condData)+1} = c0;

            <span class="comment">% Photon noise</span>
            c0.photonNoise = <span class="string">'random'</span>;      <span class="comment">% select from {'random', 'frozen', 'none'}</span>
            c0.osNoise = <span class="string">'none'</span>;            <span class="comment">% select from {'random', 'frozen', 'none'}</span>
            condData{numel(condData)+1} = c0;

            <span class="comment">% OS noise</span>
            c0.photonNoise = <span class="string">'none'</span>;        <span class="comment">% select from {'random', 'frozen', 'none'}</span>
            c0.osNoise = <span class="string">'random'</span>;          <span class="comment">% select from {'random', 'frozen', 'none'}</span>
            condData{numel(condData)+1} = c0;

            <span class="comment">% Both photon noise and OS noise</span>
            c0.photonNoise = <span class="string">'random'</span>;      <span class="comment">% select from {'random', 'frozen', 'none'}</span>
            c0.osNoise = <span class="string">'random'</span>;          <span class="comment">% select from {'random', 'frozen', 'none'}</span>
            condData{numel(condData)+1} = c0;

        <span class="comment">% Custom condition - customize it !</span>
        <span class="keyword">case</span> 4

            <span class="comment">% Custom</span>
            stimulusRefreshRateInHz = 66;
            integrationTime = 50/1000;

            <span class="comment">% Steady params</span>
            c0 = struct(<span class="keyword">...</span>
                <span class="string">'mosaicSize'</span>, 0.5, <span class="keyword">...</span><span class="comment">                                           % FOV = 0.5 x 0.5 deg</span>
                <span class="string">'meanLuminance'</span>, meanLuminance, <span class="keyword">...</span><span class="comment">                              % scene mean luminance</span>
                <span class="string">'modulation'</span>, 0.5, <span class="keyword">...</span><span class="comment">                                           % modulation against background</span>
                <span class="string">'modulationRegion'</span>, <span class="string">'CENTER'</span>, <span class="keyword">...</span><span class="comment">                                % modulate the center only  (choose b/n 'FULL', and 'CENTER')</span>
                <span class="string">'stimulusSamplingInterval'</span>,  1/stimulusRefreshRateInHz, <span class="keyword">...</span>
                <span class="string">'integrationTime'</span>, integrationTime, <span class="keyword">...</span>
                <span class="string">'osTimeStep'</span>, 0.1/1000, <span class="keyword">...</span><span class="comment">                                      % 0.1 millisecond</span>
                <span class="string">'photonNoise'</span>, <span class="string">'none'</span>, <span class="keyword">...</span><span class="comment">                                       % select from {'random', 'frozen', 'none'}</span>
                <span class="string">'osNoise'</span>, <span class="string">'none'</span>);                                              <span class="comment">% select from {'random', 'frozen', 'none'}</span>

           condData{numel(condData)+1} = c0;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####
function t_osTimeStep
%
% Demonstrate simulations using three different timebases, one for stimuli (based on stimulus refresh rate), 
% one for absorptions and eye movements (based on coneMosaic.integrationTime), and a third one for 
% outer segment current computations (based on os.timeStep) 
% Also demonstrates usage of the computeForOISequence() method of @coneMosaic, which computes 
% absorptions and photocurrents for a sequence of sequentially presented optical images with eye movements.
%
% NPC, ISETBIO TEAM, 2016
%


%% Init
ieInit;

% Examine the effects of varying the integrationTime
conditionSet = 1;

% Examine effects of varying the response time interval (os.timeStep)
%conditionSet = 2;

% Examine and contrast the magnitudes of photon noise vs OS noise
%conditionSet = 3;

% Custom condition
%conditionSet = 4;

condData = makeConditionSet(conditionSet);

% Run all the conditions
for stimulusConditionIndex = 1:numel(condData)
    % Get the condition data
    c = condData{stimulusConditionIndex};   
    
    % Run the simulation for this condition
    [theConeMosaic, theOIsequence, ...
        isomerizationRateSequence, photoCurrentSequence, ...
        oiTimeAxis, absorptionsTimeAxis, photoCurrentTimeAxis] = runSimulation(c.mosaicSize, c.meanLuminance, c.modulation, c.modulationRegion, c.stimulusSamplingInterval, c.integrationTime, c.osTimeStep, c.photonNoise, c.osNoise);
    
    % Plot the results
    plotEverything(theConeMosaic, theOIsequence, isomerizationRateSequence, photoCurrentSequence, oiTimeAxis, absorptionsTimeAxis, photoCurrentTimeAxis, stimulusConditionIndex, c);
end

end

function [theConeMosaic, theOIsequence, ...
    isomerizationRateSequence, photoCurrentSequence, ...
    oiTimeAxis, absorptionsTimeAxis, photoCurrentTimeAxis] = runSimulation(mosaicSize, meanLuminance,  modulationGain, modulationRegion, stimulusSamplingInterval, integrationTime, osTimeStep, photonNoise, osNoise)

    % Define the time axis for the simulation
    minTime = -0.84;
    maxTime = 0.72;
    oiTimeAxis = minTime:stimulusSamplingInterval:maxTime;
    
    % Compute the stimulus modulation function
    stimulusRampTau = 0.18;
    modulationFunction = modulationGain * exp(-0.5*(oiTimeAxis/stimulusRampTau).^2);

    % Generate a uniform field scene with desired mean luminance
    if (isnan(mosaicSize))
        FOV = 0.2;
    else
        FOV = max(mosaicSize);
    end
    theScene = uniformFieldSceneCreate(FOV, meanLuminance);

    % Generate optics
    noOptics = false;
    theOI = oiGenerate(noOptics);

    % Generate the sequence of optical images
    theOIsequence = oiSequenceGenerate(theScene, theOI, oiTimeAxis, modulationFunction, modulationRegion);

    % Generate the cone mosaic with eye movements for theOIsequence
    theConeMosaic = coneMosaicGenerate(mosaicSize, photonNoise, osNoise, integrationTime, osTimeStep);

    % Generate eye movement sequence for all oi's
    eyeMovementsNum = theOIsequence.maxEyeMovementsNumGivenIntegrationTime(theConeMosaic.integrationTime);
    theConeMosaic.emGenSequence(eyeMovementsNum);
    
    [absorptionsCountSequence, photoCurrentSequence] = ...
            theConeMosaic.computeForOISequence(theOIsequence, ...
            'currentFlag', true ...
            );
    absorptionsTimeAxis = theConeMosaic.timeAxis + theOIsequence.timeAxis(1);  
    photoCurrentTimeAxis = absorptionsTimeAxis;
    
    %theOIsequence.visualizeWithEyeMovementSequence(absorptionsTimeAxis);
    
    % Compute photon rate from photon count
    isomerizationRateSequence = absorptionsCountSequence / theConeMosaic.integrationTime;
end


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- Helper functions REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

function theConeMosaic = coneMosaicGenerate(mosaicSize, photonNoise, osNoise, integrationTime, osTimeStep)
    % Default human mosaic
    theConeMosaic = coneMosaic;
    
    % Adjust size
    if isnan(mosaicSize)
        % Generate a human cone mosaic with 1L, 1M and 1S cone
        theConeMosaic.rows = 1;
        theConeMosaic.cols = 3;
        theConeMosaic.pattern = [2 3 4];
    else
        theConeMosaic.setSizeToFOV(mosaicSize);
    end
    
    % Set the noise
    theConeMosaic.noiseFlag = photonNoise;

    % Set the integrationTime
    theConeMosaic.integrationTime = integrationTime;
    
    % Generate the outer-segment object to be used by the coneMosaic
    theOuterSegment = osLinear();
    theOuterSegment.noiseFlag = osNoise;
    
    % Set a custom timeStep, for @osLinear we do not need the default 0.1 msec
    theOuterSegment.timeStep = osTimeStep;

    % Couple the outersegment object to the cone mosaic object
    theConeMosaic.os = theOuterSegment;
end


function theOIsequence = oiSequenceGenerate(theScene, theOI, oiTimeAxis, modulationFunction, modulationType)
    % Compute the background and modulated optical images
    oiBackground = oiCompute(theOI, theScene);
    oiModulated  = oiBackground;
    
    if strcmp(modulationType, 'FULL')
        theOIsequence = oiSequence(oiBackground, oiModulated, oiTimeAxis, modulationFunction, 'composition', 'add');
    else
        pos = oiGet(oiBackground, 'spatial support', 'microns');
        modulationRegion.radiusInMicrons = 0.75*max(pos(:));
        theOIsequence = oiSequence(oiBackground, oiModulated, oiTimeAxis, modulationFunction, 'modulationRegion', modulationRegion);
    end
end


function theOI = oiGenerate(noOptics)
    % Generate optics
    if (noOptics)
        theOI = oiCreate('diffraction limited');
        optics = oiGet(theOI,'optics');           
        optics = opticsSet(optics,'fnumber',0);
        optics = opticsSet(optics, 'off axis method', 'skip');
        theOI = oiSet(theOI,'optics', optics);
    else
        theOI = oiCreate('human');
    end
end


function uniformScene = uniformFieldSceneCreate(FOV, meanLuminance)
    uniformScene = sceneCreate('uniform equal photon', 128);
    % square scene with desired FOV
    uniformScene = sceneSet(uniformScene, 'wAngular', FOV);
    % 1 meter away
    uniformScene = sceneSet(uniformScene, 'distance', 1.0);
    % adjust radiance according to desired  mean luminance
    uniformScene = sceneAdjustLuminance(uniformScene, meanLuminance);
end


function plotEverything(theConeMosaic, theOIsequence, isomerizationRateSequence, photoCurrentSequence, oiTimeAxis, absorptionsTimeAxis, responseTimeAxis, figNo, condData)

    % Plot the sequence of OIs with the eye movements 
    hFig = figure(figNo); clf;
    set(hFig, 'Position', [10+figNo*50 10+figNo*100 1920 760], 'Color', [1 1 1]);
    set(hFig, 'Name', sprintf('Scene Mean Luminance: %2.1f cd/m2,     Modulation: %2.2f,     Stimulus Sampling: %2.1f ms,     Integration Time: %2.1f ms,   osTimeStep: %2.1f ms,      PhotonNoise: %s,      osNoise: %s', condData.meanLuminance, condData.modulation, condData.stimulusSamplingInterval*1000, condData.integrationTime*1000, condData.osTimeStep*1000, condData.photonNoise, condData.osNoise));

    tabGroup = uitabgroup('Parent', hFig);
    
    eyeMovementsTab = uitab(tabGroup, 'Title', '2D eye movements and OI sequence', 'BackgroundColor', [1 1 1], 'ForegroundColor', [0 0 1]);
    timeSeriesTab = uitab(tabGroup, 'Title', 'Time series: optical image photon rate, eye movements, aborptions, & photocurrents', 'BackgroundColor', [1 1 1], 'ForegroundColor', [0 0 1]);
    
    set(tabGroup, 'SelectedTab',eyeMovementsTab);
    axes('parent',eyeMovementsTab);

    
    plotRows = round(0.75*sqrt(theOIsequence.length)); 
    plotCols = ceil(theOIsequence.length/plotRows);
    subplotPosVectors = NicePlot.getSubPlotPosVectors(...
           'rowsNum', plotRows, ...
           'colsNum', plotCols, ...
           'heightMargin',   0.03, ...
           'widthMargin',    0.03, ...
           'leftMargin',     0.03, ...
           'rightMargin',    0.00, ...
           'bottomMargin',   0.03, ...
           'topMargin',      0.02);
       
    maxRGB = 0;
    for oiIndex = 1:theOIsequence.length
        tmp = xyz2rgb(oiGet(theOIsequence.frameAtIndex(oiIndex), 'xyz'));
        if (maxRGB < max(tmp(:)))
            maxRGB = max(tmp(:));
        end
         oiImage{oiIndex} = tmp;
    end
    
    % Retrieve the eye movement sequence
    eyeMovementSequence = theConeMosaic.emPositions;
    
    for oiIndex = 1:theOIsequence.length
        pos = oiGet(theOIsequence.frameAtIndex(oiIndex), 'spatial support', 'microns');
        oiXaxis = pos(1,:,1); oiYaxis = pos(:,1,2);
        r = floor((oiIndex-1)/plotCols)+1;
        c = mod((oiIndex-1), plotCols)+1;
        subplot('Position', subplotPosVectors(r,c).v);
        
        % Plot the OI
        imagesc(oiXaxis, oiYaxis, oiImage{oiIndex}/maxRGB);
        % Overlay the eye movements up to this point
        hold on;
        idx = find(absorptionsTimeAxis < oiTimeAxis(oiIndex));
        plot(eyeMovementSequence(idx,1)*theConeMosaic.pigment.width*1e6, eyeMovementSequence(idx,2)*theConeMosaic.pigment.width*1e6, 'ks-', 'LineWidth', 1.5, 'MarkerFaceColor', [0.3 0.3 0.3]);
        if (oiIndex < theOIsequence.length)
            idx = find((absorptionsTimeAxis>=oiTimeAxis(oiIndex)) & (absorptionsTimeAxis<oiTimeAxis(oiIndex+1)));
        else
            idx = find((absorptionsTimeAxis>=oiTimeAxis(oiIndex)));
        end
        % Emphasize in red, the eye movements for the current framer
        plot(eyeMovementSequence(idx,1)*theConeMosaic.pigment.width*1e6, eyeMovementSequence(idx,2)*theConeMosaic.pigment.width*1e6, 'rs-', 'LineWidth', 1.5, 'MarkerFaceColor', [1.0 0.5 0.5]);
        
        % overlay the cone mosaic
        if (oiIndex == 1)
            plot(theConeMosaic.coneLocs(:,1)*1e6, theConeMosaic.coneLocs(:,2)*1e6, 'k.');
        end
        
        axis 'image'; axis 'xy';
        set(gca, 'CLim', [0 1], 'FontSize', 14);
        if ~((r == plotRows) && (c == 1))
            set(gca, 'XTick', [], 'YTick', []);
        end
        title(sprintf('t: %2.1f msec', 1000*oiTimeAxis(oiIndex)), 'FontSize', 14);
    end
    
    % Plot time-series responses
    set(tabGroup, 'SelectedTab',timeSeriesTab);
    axes('parent',timeSeriesTab);
    
    %% Plot the photon rate at the center of the optical image
    subplot('Position', [0.03 0.07 0.18 0.89]);
    oiWavelengthAxis = oiGet(theOIsequence.frameAtIndex(1), 'wave');
    referencePositionOpticalImagePhotons = zeros(numel(oiWavelengthAxis), theOIsequence.length);
    for oiIndex = 1:theOIsequence.length
        retinalPhotonsAtCurrentFrame = oiGet(theOIsequence.frameAtIndex(oiIndex), 'photons');
        refRow = round(size(retinalPhotonsAtCurrentFrame,1)/2);
        refCol = round(size(retinalPhotonsAtCurrentFrame,2)/2);
        referencePositionOpticalImagePhotons(:, oiIndex) = squeeze(retinalPhotonsAtCurrentFrame(refRow, refCol, :));
    end
    hP = pcolor(oiTimeAxis, oiWavelengthAxis, referencePositionOpticalImagePhotons);
    set(hP, 'EdgeColor', 'none');
    hold on;
    % Plot the total photons (summed across all wavelengths)
    totalPhotons = sum(referencePositionOpticalImagePhotons,1);
    totalPhotonsNorm = oiWavelengthAxis(1) + (oiWavelengthAxis(end)-oiWavelengthAxis(1))*(totalPhotons-min(totalPhotons))/(max(totalPhotons)-min(totalPhotons));
    stairs(oiTimeAxis, totalPhotonsNorm, 'c-', 'LineWidth', 2.0);
    plotStimulusTimes([min(totalPhotonsNorm) max(totalPhotonsNorm)]);
    
    hold off; box on
    set(gca, 'YLim', [oiWavelengthAxis(1) oiWavelengthAxis(end)], 'XLim', [oiTimeAxis(1) oiTimeAxis(end)], 'FontSize', 14);
    xlabel('time (seconds)', 'FontSize', 14, 'FontWeight', 'bold');
    ylabel('wavelength (nm)', 'FontSize', 14, 'FontWeight', 'bold');
    title('optical image photon rate (image center)', 'FontSize', 14);
    hC = colorbar('Location', 'NorthOutside', 'parent', timeSeriesTab);
    hC.FontSize =  14;
    hC.Label.String = 'photons/sec';
    axis 'xy'
    colormap(gray(1024));

    %% Plot the eye movement sequence (different colors for different OIs)
    subplot('Position', [0.25 0.07 0.22 0.89]); hold on;
    eyeMovementRange = [-100 100];

    plot(absorptionsTimeAxis, eyeMovementSequence(:,1)*theConeMosaic.pigment.width*1e6, '.', 'MarkerSize', 15, 'Color', 'r');
    hold on;
    plot(absorptionsTimeAxis, eyeMovementSequence(:,2)*theConeMosaic.pigment.height*1e6, '.', 'MarkerSize', 15, 'Color', 'b');
    plotStimulusTimes(eyeMovementRange);
    
    box on
    set(gca, 'YLim', [eyeMovementRange(1) eyeMovementRange(end)], 'XLim', [oiTimeAxis(1) oiTimeAxis(end)], 'FontSize', 14);
    legend({'eye position (X)', 'eye position (Y)'});
    ylabel('X,Y eye position (microns)', 'FontSize', 14, 'FontWeight', 'bold');
    xlabel('time (seconds)', 'FontSize', 14, 'FontWeight', 'bold');
    title('X,Y eye movements', 'FontSize', 14);
    
    
    %% Plot the LMS isomerizations
    if (theConeMosaic.rows ==1) && (theConeMosaic.cols == 3)
       referenceConeRows = [1 1 1]; referenceConeCols = [1 2 3];
    else
       % Find the (row,col) coords of the center-most L, M and S-cone
       for k = 1:3
            coneIndices = find(theConeMosaic.pattern == k+1); 
            [~, idx] = min(sum((theConeMosaic.coneLocs(coneIndices,:)).^2, 2));
            [referenceConeRows(k), referenceConeCols(k)] = ind2sub(size(theConeMosaic.pattern), coneIndices(idx));
       end
    end
    subplot('Position', [0.50 0.07 0.22 0.89]);
    isomerizationRange = [min(isomerizationRateSequence(:)) 1.05*max(isomerizationRateSequence(:))];
    hold  on
    coneColors = [1 0 0; 0 1 0; 0 0 1];
    for k = 1:3
        plot(absorptionsTimeAxis, squeeze(isomerizationRateSequence(1, referenceConeRows(k),referenceConeCols(k),:)), '.', 'Color', squeeze(coneColors(k,:)), 'MarkerSize', 15, 'LineWidth', 1.5);
    end
    plotStimulusTimes(isomerizationRange);
    
    hold off;
    set(gca, 'YLim', isomerizationRange, 'XLim', [oiTimeAxis(1) oiTimeAxis(end)], 'FontSize', 14);
    ylabel('isomerization rate (R*/cone/sec)', 'FontSize', 14, 'FontWeight', 'bold');
    xlabel('time (seconds)', 'FontSize', 14, 'FontWeight', 'bold');
    title('L,M,S-cone isomerization rates', 'FontSize', 14);

    %% Plot the photocurrents
    subplot('Position', [0.75 0.07 0.22 0.89]);
    photoCurrentRange = [min(photoCurrentSequence(:)) max(photoCurrentSequence(:))+2];
    hold on;
    for k = 1:3
        plot(responseTimeAxis, squeeze(photoCurrentSequence(1, referenceConeRows(k),referenceConeCols(k),:)), 'k.', 'Color', squeeze(coneColors(k,:)), 'MarkerSize', 15, 'LineWidth', 1.5);
    end
    plotStimulusTimes(photoCurrentRange);
    
    hold off;
    set(gca, 'XLim', [oiTimeAxis(1) oiTimeAxis(end)], 'YLim', photoCurrentRange, 'FontSize', 14);
    ylabel('photocurrent (pA)', 'FontSize', 14, 'FontWeight', 'bold');
    xlabel('time (seconds)', 'FontSize', 14, 'FontWeight', 'bold');
    title('@osLinear response', 'FontSize', 14);
    
    % Switch to eye movements tab
    set(tabGroup, 'SelectedTab',eyeMovementsTab);
    
    drawnow
    
    function plotStimulusTimes(signalRange)
        % Plot lines demarkating each OI time duration
        for oiIndex = 1:theOIsequence.length
            plot(oiTimeAxis(oiIndex)*[1 1], signalRange, 'k-');
        end
        % Plot the origin in magenta
        plot([0 0], signalRange, '-', 'Color', [0.7 0.1 0.3], 'LineWidth', 2);
    end

end


function condData = makeConditionSet(conditionSet)

    % scene mean luminance
    meanLuminance = 1500;    
    
    % Assemble conditions to run.
    condData = {};

    switch conditionSet

        % Effects of varying the integrationTime
        case 1
            % Steady params
            c0 = struct(...
                'mosaicSize', nan, ...                      % 1 L-, 1 M-, and 1 S-cone only
                'meanLuminance', meanLuminance, ...         % scene mean luminance
                'modulation', 0.5, ...                      % 50%  modulation against background
                'modulationRegion', 'CENTER', ...           % modulate the central image (choose b/n 'FULL', and 'CENTER')
                'stimulusSamplingInterval',  1/50, ...      % 50 Hz stimulus refresh, e.g., 20 msec per optical image
                'osTimeStep', 0.1/1000, ...                 % 0.1 millisecond
                'integrationTime', nan, ...                 % we will vary this one
                'photonNoise', 'random', ...                % select from {'random', 'frozen', 'none'}
                'osNoise', 'none');                         % select from {'random', 'frozen', 'none'}
            
            % Varied params
            c0.integrationTime = 100/1000;                  % 100 ms (longer than the stimulus sampling interval, so < 1 eye movement / oi)
            condData{numel(condData)+1} = c0;
            
            c0.integrationTime = 10/1000;                   % 10 ms (smaller than the stimulus sampling interval, 2 eye movements / oi)
            condData{numel(condData)+1} = c0;
            
            c0.integrationTime = 1/1000;                    % 1 ms (20 eye movements / oi)
            condData{numel(condData)+1} = c0;
            
        % Examine effects of varying the os.timeStep
        case 2
            % Steady params
            c0 = struct(...
                'mosaicSize', nan, ...                      % 1 L-, 1 M-, and 1 S-cone only
                'meanLuminance', meanLuminance, ...         % scene mean luminance
                'modulation', 0.5, ...                      % 50%  modulation against background
                'modulationRegion', 'CENTER', ...           % modulate the central image (choose b/n 'FULL', and 'CENTER')
                'stimulusSamplingInterval',  1/10, ...      % 100 Hz stimulus refresh
                'integrationTime', 20/1000, ...             % 20 milliseconds
                'osTimeStep', nan, ...                      % we'll vary that one
                'photonNoise', 'random', ...                    % select from {'random', 'frozen', 'none'}
                'osNoise', 'none');                         % select from {'random', 'frozen', 'none'}

            % Varied params
            c0.osTimeStep = 1/1000;                    % 1 milliseconds
            condData{numel(condData)+1} = c0;
            
            c0.osTimeStep = 0.5/1000;                  % 0.5 milliseconds
            condData{numel(condData)+1} = c0;
            
            c0.osTimeStep = 0.1/1000;                  % 0.1 milliseconds
            condData{numel(condData)+1} = c0;
            
        
            
        % Examine and contrast the magnitudes of photon noise vs OS noise
        case 3    
         
            stimulusRefreshRateInHz = 25;
            eyeMovementsPerStimulusRefresh = 6;
            
            % Steady params
            c0 = struct(...
                'mosaicSize', nan, ...                      % 1 L-, 1 M-, and 1 S-cone only
                'meanLuminance', meanLuminance, ...         % scene mean luminance
                'modulation', 0.5, ...                      % % modulation against background
                'modulationRegion', 'CENTER', ...           % modulate the center only  (choose b/n 'FULL', and 'CENTER')
                'stimulusSamplingInterval',  1/stimulusRefreshRateInHz, ...      
                'integrationTime', 5/1000, ...             % 5 milliseconds
                'osTimeStep', 0.1/1000, ...  
                'photonNoise', nan, ...
                'osNoise', nan);
            
            % Varied params
            % No noise
            c0.photonNoise = 'none';        % select from {'random', 'frozen', 'none'}
            c0.osNoise = 'none';            % select from {'random', 'frozen', 'none'}
            condData{numel(condData)+1} = c0;
            
            % Photon noise
            c0.photonNoise = 'random';      % select from {'random', 'frozen', 'none'}
            c0.osNoise = 'none';            % select from {'random', 'frozen', 'none'}
            condData{numel(condData)+1} = c0;
            
            % OS noise 
            c0.photonNoise = 'none';        % select from {'random', 'frozen', 'none'}
            c0.osNoise = 'random';          % select from {'random', 'frozen', 'none'}
            condData{numel(condData)+1} = c0;
            
            % Both photon noise and OS noise
            c0.photonNoise = 'random';      % select from {'random', 'frozen', 'none'}
            c0.osNoise = 'random';          % select from {'random', 'frozen', 'none'}
            condData{numel(condData)+1} = c0;
            
        % Custom condition - customize it !
        case 4
            
            % Custom
            stimulusRefreshRateInHz = 66;
            integrationTime = 50/1000;
            
            % Steady params
            c0 = struct(...
                'mosaicSize', 0.5, ...                                           % FOV = 0.5 x 0.5 deg
                'meanLuminance', meanLuminance, ...                              % scene mean luminance
                'modulation', 0.5, ...                                           % modulation against background
                'modulationRegion', 'CENTER', ...                                % modulate the center only  (choose b/n 'FULL', and 'CENTER')
                'stimulusSamplingInterval',  1/stimulusRefreshRateInHz, ...      
                'integrationTime', integrationTime, ...     
                'osTimeStep', 0.1/1000, ...                                      % 0.1 millisecond
                'photonNoise', 'none', ...                                       % select from {'random', 'frozen', 'none'}
                'osNoise', 'none');                                              % select from {'random', 'frozen', 'none'}
            
           condData{numel(condData)+1} = c0;
    end
end

##### SOURCE END #####
--></body></html>