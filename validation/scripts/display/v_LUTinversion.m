function varargout = v_LUTinversion(varargin)
%
% Validate display calibration and compare against PTB answers.
%

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
end

%% Function implementing the isetbio validation code
function ValidationFunction(runTimeParams)

    %% Initialize ISET
    s_initISET;
    
    %% Remove the brainard lab PTB overrides
    [removedFolderFromCurrentPath, originalPath] = removeBrainardLabPTBOverrides();
    
    try
        
        %% Compare PTB vs ISETBIO LUT inversion for three different displays
        displaysToTest = {'OLED-Sony', 'LCD-Apple', 'CRT-Dell'};
        
        %% and four different gamma table lengths
        gammaTableLengthsToTest = [128 256 1024 2048];
        
        for displayIndex = 1:numel(displaysToTest)
            
            %% Create a display object
            d = displayCreate(displaysToTest{displayIndex});

            %% Retriece key properties of the display
            % Gamma table
            gammaTable = displayGet(d, 'gamma table');
            if (size(gammaTable,2) > 3)
                gammaTable = gammaTable(:,1:3);
            end
            originalGammaTableLength = size(gammaTable,1);
            originalSettingsValues   = linspace(0,1,originalGammaTableLength);
            
            % Primary SPD
            wave         = displayGet(d, 'wave');
            spd          = displayGet(d, 'spd primaries');
            
            % Screen size and DPI
            dotsPerMeter = displayGet(d, 'dots per meter');
            screenSizeInPixels = [1920 1080];
                
            %% Generate PTB-compatible calStruct describing the display
            PTBcal = generatePsychToolboxCalStruct(gammaTable, wave, spd, screenSizeInPixels, dotsPerMeter);
                
            for resolutionIndex = 1:numel(gammaTableLengthsToTest)
                %% Compute the inverse gamma table with desired resolution
                nInputLevels = gammaTableLengthsToTest(resolutionIndex);
                
                % PTB-solution
                PTBcal = CalibrateFitGamma(PTBcal, nInputLevels);
                gammaMethod = 1;
                PTBcal = SetGammaMethod(PTBcal, gammaMethod, nInputLevels);
                PTBinverseGamma       = PTBcal.iGammaTable;
                settingsValues        = PTBcal.gammaInput;

                % ISETBIO solution
                ISETBIOinverseGamma = displayGet(d, 'inverse gamma', nInputLevels);
                % ISETBIOinverseGamma = ieLUTInvert(gammaTable,nInputLevels);
                ISETBIOinverseGamma = ISETBIOinverseGamma / (originalGammaTableLength-1);
                
                % Log the data 
                dataStruct = struct( ...
                    'displayName', displaysToTest{displayIndex}, ...
                    'originalSettingsValues', originalSettingsValues, ...
                    'gammaTable', gammaTable, ...
                    'nInputLevels', nInputLevels, ...
                	'settingsValues', settingsValues, ...
                	'PTBinverseGamma', PTBinverseGamma, ...
                	'ISETBIOinverseGamma', ISETBIOinverseGamma ...
                 );
                
                data{displayIndex}{resolutionIndex} = dataStruct;
            end
        end
        
    catch err
        if (~isempty(removedFolderFromCurrentPath))
            % restore original path
            path(originalPath);
        end
        rethrow(err);
    end
    
    
    %% Plot
    if (runTimeParams.generatePlots)
        h = figure(1);
        set(h, 'Position', [10 10 1704 1196]);
        clf;
        
        subplotIndex = 0;
        for displayIndex = 1:numel(displaysToTest)
            for resolutionIndex = 1:numel(gammaTableLengthsToTest)
                
                dataStruct = data{displayIndex}{resolutionIndex};
                subplotIndex = subplotIndex + 1;
                subplot(numel(displaysToTest),numel(gammaTableLengthsToTest),subplotIndex);
                hold on;
                
                % Plot results for RED channel only
                channelIndex = 1;
                
                % original gamma
                plot(dataStruct.originalSettingsValues, dataStruct.gammaTable(:,channelIndex), 'g.');
                
                % PTB-inverted
                plot(dataStruct.settingsValues, dataStruct.PTBinverseGamma(:,channelIndex), 'r.');
                
                % ISETBIO-inverted
                plot(dataStruct.settingsValues, dataStruct.ISETBIOinverseGamma(:,channelIndex), 'b.');
                
                % ISETBIO-inverted
                plot(dataStruct.settingsValues, 0.5+dataStruct.PTBinverseGamma(:,channelIndex)-dataStruct.ISETBIOinverseGamma(:,channelIndex), 'k-', 'LineWidth', 2.0);
                
                hold off;
                
                h_legend = legend('Orig. LUT', 'PTB inverse', 'ISETBIO inverse', '0.5+(PTB-ISETBIO)', 'Location', 'NorthWest');
                set(h_legend,'FontName', 'Menlo', 'FontSize',12);
                
                set(gca, 'XLim', [0 1], 'YLim', [0 1], 'XTick', [0:0.1:1.0], 'YTick', [0:0.1:1.0], 'FontSize', 12, 'FontName', 'Helvetica');
                xlabel('gamma in','FontSize', 12, 'FontName', 'Helvetica', 'FontWeight', 'bold');
                ylabel('gamma out', 'FontSize', 12, 'FontName', 'Helvetica', 'FontWeight', 'bold');
                axis 'square'; box on; grid on;
                title(sprintf('%s - (%d levels)', dataStruct.displayName, dataStruct.nInputLevels), 'FontSize', 16, 'FontName', 'Helvetica', 'FontWeight', 'bold');
                hold off
            end
        end
    end
    
    
end

%% Helper functions

% Method to generate a PTB CalStruct for a display with given properties
function cal = generatePsychToolboxCalStruct(gammaTable, wave, spd, screenSizeInPixels, dotsPerMeter)

    spectralSamples  = size(wave,1);
    gammaTableLength = size(gammaTable,1);
    nDevices         = size(gammaTable,2);
    gammaInput       = linspace(0,1,gammaTableLength);
    
    displayDescriptionStruct = struct( ...
     'screenSizeMM', screenSizeInPixels/(dotsPerMeter/1000), ...
  'screenSizePixel', screenSizeInPixels, ...
      'refreshRate', 60, ...
     'bitsPerPixel', 32, ...
    'bitsPerSample', 8, ...
  'samplesPerPixel', nDevices ...
        );

    gammaStruct = struct(...
          'fitType','simplePower', ...
   'contrastThresh', [], ...
        'exponents', [], ...
   'fitBreakThresh', [], ...
        'useweight', [] ...
        );
    
    describeStruct = struct( ...
                     'S', WlsToS(wave), ...
      'blankOtherScreen', 1, ...
         'blankSettings', [0.3962 0.3787 0.4039], ...
            'boxOffsetX', 0, ...
            'boxOffsetY', 0, ...
               'boxSize', 150, ...
       'calibrationType', 'name of display', ...
               'caltype', 'monitor', ...
               'comment', 'some comment', ...
              'computer', 'some brainard lab computer', ...
               'dacsize', 8, ...
                  'date', 'date of calibration', ...
    'displayDescription', displayDescriptionStruct, ...
                'driver', 'unknown_driver unknown_driver_version', ...
                 'gamma', gammaStruct, ...
                    'hz', 60, ...
         'leaveRoomTime', 10, ...
         'meterDistance', 0.5000, ...
               'monitor', 'StereoLCDLeft', ...
              'nAverage', 2, ...
                 'nMeas', 25, ...
               'program', 'mglCalibrateMonSpd', ...
         'promptforname', 1, ...
       'screenSizePixel', [1920 1200], ...
               'svnInfo', struct(), ...
      'whichBlankScreen', 3, ...
        'whichMeterType', 5, ...
           'whichScreen', 2, ...
                   'who', 'name of person that did the calibration', ...
           'yokedmethod', [] ...
        );
    
    rawDataStruct = struct(...
       'rawGammaInput', gammaInput', ...
       'rawGammaTable', gammaTable ...
    );
    
    
    % Generate a calStruct suitable for use with PTB Cal functions
    cal = struct(...
            'describe', describeStruct, ...
    'M_ambient_linear', [], ...
     'M_device_linear', [], ...
     'M_linear_device', [], ...
           'P_ambient', zeros(size(spectralSamples,1), 1), ... 
            'P_device', spd, ...
           'S_ambient', WlsToS(wave), ...
            'S_device', [], ...
            'S_linear', [], ...
            'S_sensor', [], ...
           'T_ambient', eye(spectralSamples), ...
            'T_device', eye(spectralSamples), ...
            'T_linear', [], ...
            'T_sensor', [], ...
      'ambient_linear', [], ...
           'basicmeas', struct(), ...
             'bgColor', [0.3962 0.3787 0.4039], ...
              'bgmeas', struct(), ...
             'fgColor', [0.3962 0.3787 0.4039], ...
         'gammaFormat', 0, ...
          'gammaInput', gammaInput', ...
           'gammaMode', [], ...
          'gammaTable', gammaTable, ...
         'iGammaTable', [], ...
             'rawdata', rawDataStruct, ...
            'nDevices', nDevices, ...
       'nPrimaryBases', 1 ...
  );
  
end

% Method to remove the BrainardLabPTBOverrides (if they exist on the host computer)
function [removedFolderFromCurrentPath, originalPath] = removeBrainardLabPTBOverrides

    removedFolderFromCurrentPath = '';
    originalPath = path;
    
    % Folder to remove from the current path (if it is found on it)
    PTBoverridesDirToRemoveFromPath = '/Users/Shared/Matlab/Toolboxes/BrainardLabToolbox/Overrides/PTB-3/PsychCal';
    
    % determine if the PTBoverridesDirToRemoveFromPath is in the current path
    pathCell = regexp(path, pathsep, 'split');
    onPath = any(strcmpi(PTBoverridesDirToRemoveFromPath, pathCell));
    if (onPath)
        rmpath(PTBoverridesDirToRemoveFromPath);
        removedFolderFromCurrentPath = PTBoverridesDirToRemoveFromPath;
    end
end

