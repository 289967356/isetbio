classdef rgcSubunit < rgcMosaic
% rgcMosaic cell type with a nonlinear subunit computational model
%
% The nonlinear subunit model is found in Baccus SA, Ölveczky BP, Manu M,
% Meister M (2008) A retinal circuit that computes object motion. J
% Neurosci 28(27):6807?6817. The primary difference between rgcSubunit and
% rgcGLM is that the subunit model uses sum(exp(RF.*stim)) whereas the GLM
% uses exp(sum(RF.*stim)).
%
% This model utilizes spiking code from Pillow, Shlens, Paninski, Sher,
% Litke, Chichilnisky & Simoncelli, Nature (2008). The computational model
% implemented here relies on code by
% <http://pillowlab.princeton.edu/code_GLM.html Pillow>, which is
% distributed under the GNU General Public License.
%
% rgcSubunit is a subclass of rgcMosaic. It is called when creating a new
% subunit model rgcMosaic for an inner retina object.  Typically we get
% here from the inner retina object via a call
%
%   ir.mosaicCreate('model','subunit','type','your type goes here')
% 
% See also:
%
% Example:
%   os = osCreate('identity');        % A pass through from the stimulus
%   ir = irCreate(os,'name','myRGC'); % An inner retina container
%   ir.mosaicCreate('model','subunit','type','on midget'); % This  mosaic
%

% 9/2015 JRG


    % Public, read-only properties.
    properties (SetAccess = private, GetAccess = public)
    end
           
    % Protected properties.
    properties (SetAccess = private, GetAccess = public)

        % The linear voltage is computed from the properties of the parent
        % class, which are attached below (rgcMosaic)
        % This includes the first voltage response, which is called
        %
        % responseLinear
               
        % Pillow promotes the linear input voltage using a nonlinear
        % function that he calls the generator function.  By default this
        % is an exponential.
        generatorFunction;
        
        rectifyFunction;
        % Parameter to specify the time bins Pillow uses for coupling and
        % post spike filters (10 ms default)
        dt = 0.01;
        
        % The nonlinear voltage response after application of the generator
        % function and the spike coupling responses is represented here
        responseVoltage;
        
        % The spikes are computed from the response voltage
        responseSpikes;

        % nlResponse;   Delete me
        
        % We typically run a single trial
        numberTrials = 10;
        
        % Subunit threshold
        subunitThreshold = 0;
        
        % These hold the parameters used in the computation.
        % This is the response after a spike
        postSpikeFilter;
        
        % This is the time course of the voltage responses generated by a
        % spike and propagated to nearby neurons
        couplingFilter;
        
        % This is the matrix of connections between nearby neurons
        couplingMatrix;
        
        numberSubunits;

    end
    
    % Private properties. Only methods of the parent class can set these
    properties(Access = private)
    end
    
    % Public methods
    methods
        
        % Constructor
        function obj = rgcSubunit(rgc, mosaicType)
            % Initialize the parent class            
            obj = obj@rgcMosaic(rgc, mosaicType);

            % Initialize ourselves
            obj.numberSubunits = size(obj.sRFcenter{1,1});
            
            obj.generatorFunction = @(x) exp(x); %@exp;
            
            obj.rectifyFunction = @(x) x.*(x>0); % used to implement subunit nonlinearity
            
            obj.postSpikeFilter = buildPostSpikeFilter(.01);
            
            [obj.couplingFilter, obj.couplingMatrix] = buildCouplingFilters(obj, .01);
            
            % Make temporal IR just an impulse
            tCenterOrig = obj.mosaicGet('tCenter');
            
            tCenterNew{1} = zeros(size(tCenterOrig));
            tCenterNew{2} = zeros(size(tCenterOrig));
            tCenterNew{3} = zeros(size(tCenterOrig));
            
            tImpulse = 4;
            tCenterNew{1}(1) = tImpulse; tCenterNew{2}(1) = tImpulse; tCenterNew{3}(1) = tImpulse;
            obj.mosaicSet('tCenter',tCenterNew);
            
            tSurroundNew{1} = zeros(size(tCenterOrig));
            tSurroundNew{2} = zeros(size(tCenterOrig));
            tSurroundNew{3} = zeros(size(tCenterOrig));
            tSurroundNew{1} = -tImpulse; tSurroundNew{2} = -tImpulse; tSurroundNew{3} = -tImpulse;
            obj.mosaicSet('tSurround',tSurroundNew);

            
        end
        
        % set function, see for details
        function obj = set(obj, varargin)
            % obj = set@rgcMosaic(obj, varargin);
            mosaicSet(obj, varargin{:});
        end
        
        % get function, see for details
        function val = get(obj, varargin)
           val = mosaicGet(obj, varargin{:});
        end
      
    end
    
    % Methods that must only be implemented (Abstract in parent class).
    methods (Access=public)
        
        % Overloaded display function to order properties as we want to
        function disp(obj)
            
            % Get the string from the builtin disp and then rearrange
            s1 =evalc('builtin(''disp'', obj'')');
            
            % Find newline character locations
            newlineChars = strfind(s1,sprintf('\n'));
            
            % Pull out lines with properties and values
            for nlInd = 2:length(newlineChars)
                propertystr{nlInd} = s1(newlineChars(nlInd-1)+1:newlineChars(nlInd)-1);
            end
            
            % Display the reordered property list
            % Display the first line with class type
            disp(sprintf('\n'));
            disp(s1(1:newlineChars(1)))
            % Order determined through trial and error
            propertyOrder = [11:20 3:4 7:10 5:6];
            for nlInd = propertyOrder
                disp(propertystr{nlInd});
            end
        end
        
    end    
    
    % Methods may be called by the subclasses, but are otherwise private 
    methods (Access = protected)

        % Make sure commented at top
        % Probably get rid of rfDiameter or derive it from sRF variables
        % Probably derive rfDiaMagnitude from variables
        
    end

end
