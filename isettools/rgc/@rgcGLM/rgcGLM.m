classdef rgcGLM < rgcMosaic
% rgcMosaic cell type with a GLM (coupled-nonlinear) computational model
%
% The coupled GLM model is published in Pillow, Shlens, Paninski, Sher,
% Litke, Chichilnisky & Simoncelli, Nature (2008).% The computational model
% implemented here relies on code by
% <http://pillowlab.princeton.edu/code_GLM.html Pillow>, which is
% distributed under the GNU General Public License.
%
% rgcGLM is a subclass of rgcMosaic. It is called when creating a new GLM
% model rgcMosaic for an inner retina object.  Typically we get here from
% the inner retina object via a call
%
%   ir.mosaicCreate('model','GLM','type','your type goes here')
% 
% See also:
%
% Example:
%   os = osCreate('identity');        % A pass through from the stimulus
%   ir = irCreate(os,'name','myRGC'); % An inner retina container
%   ir.mosaicCreate('model','glm','type','on midget'); % This  mosaic
%
% 9/2015 JRG

%% Properties 
    % Public, read-only properties.
    properties (SetAccess = private, GetAccess = public)
    end
           
    % Protected properties.
    properties (SetAccess = private, GetAccess = public)

        % The linear voltage is computed from the properties of the parent
        % class, which are attached below (rgcMosaic)
        % This includes the first voltage response, which is called
        %
        % responseLinear
               
        % Pillow promotes the linear input voltage using a nonlinear
        % function that he calls the generator function.  By default this
        % is an exponential.
        generatorFunction;
        
        % Parameter to specify the time bins Pillow uses for coupling and
        % post spike filters (10 ms default)
        dt = 0.01;
        
        % The nonlinear voltage response after application of the generator
        % function and the spike coupling responses is represented here
        responseVoltage;
        
        % The spikes are computed from the response voltage
        responseSpikes;

        % nlResponse;   Delete me
        
        % We typically run a single trial
        numberTrials = 10;
        
        % These hold the parameters used in the computation.
        % This is the response after a spike
        postSpikeFilter;
        
        % This is the time course of the voltage responses generated by a
        % spike and propagated to nearby neurons
        couplingFilter;
        
        % This is the matrix of connections between nearby neurons
        couplingMatrix;
        
    end
    
    % Private properties. Only methods of the parent class can set these
    properties(Access = private)
    end
  
%% Methods
    % Public methods
    methods
        
        % Constructor
        function obj = rgcGLM(ir, mosaicType)
            % Constructs the rgcGLM object
            %
            %       mosaic = rgcGLM(ir,mosaicType);
            %
            % The mosaic object is initialized with the generatorFunction,
            % postSpikeFilter and couplingFilter properties.
            %
            % The parent class is rgcMosaic, which specify the linear
            % convolutional properties.
            %
            % Example:
            %
            % See also: rgcMosaicCreate
            %
            % (c) isetbio
            % 09/2015 JRG
            
            % Initialize the mosaic parent class
            obj = obj@rgcMosaic(ir, mosaicType);
            
            % The Pillow generator function
            obj.generatorFunction = @exp;

            % Effect of a spike on output voltages
            obj.postSpikeFilter = buildPostSpikeFilter(obj.dt);
            
            % Coupling filters between nearby ganglion cells
            [obj.couplingFilter, obj.couplingMatrix] = buildCouplingFilters(obj, obj.dt);
            
        end
        
        % set function, see for details
        function obj = set(obj, varargin)
            % obj = set@rgcMosaic(obj, varargin);
            mosaicSet(obj, varargin{:});
        end
        
        % get function, see for details
        function val = get(obj, varargin)
           val = mosaicGet(obj, varargin{:});
        end
      
    end
    
    methods (Access = public)
        
        % Overloaded display function to order properties as we want to
        function disp(obj)
            
            % Get the string from the builtin disp and then rearrange
            s1 =evalc('builtin(''disp'', obj'')');
            
            % Find newline character locations
            newlineChars = strfind(s1,sprintf('\n'));
            
            % Pull out lines with properties and values
            for nlInd = 2:length(newlineChars)
                propertystr{nlInd} = s1(newlineChars(nlInd-1)+1:newlineChars(nlInd)-1);
            end
            
            % Display the reordered property list
            % Display the first line with class type
            disp(sprintf('\n'));
            disp(s1(1:newlineChars(1)))
            % Order determined through trial and error
            propertyOrder = [11:20 3:4 7:10 5:6];
            for nlInd = propertyOrder
                disp(propertystr{nlInd});
            end
        end
        
    end
    
    % Methods may be called by the subclasses, but are otherwise private 
    methods (Access = protected)
    end
    
    % Methods that are totally private (subclasses cannot call these)
    methods (Access = private)
    end
    
end
